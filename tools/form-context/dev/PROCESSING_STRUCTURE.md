# Структура обработки FormContextCollector.epf

## Общая информация

**Имя**: `СборщикКонтекстаФорм` (FormContextCollector)  
**Тип**: Внешняя обработка (.epf)  
**Назначение**: Сбор информации о структуре форм 1С для генерации контекста, оптимизированного для AI

---

## 1. Реквизиты обработки

### ПутьКФайлуВыгрузки
- **Тип**: Строка, неограниченная длина
- **Назначение**: Путь к файлу для сохранения результатов (JSON)
- **Значение по умолчанию**: `""`

### ВключатьТабличныеЧасти
- **Тип**: Булево
- **Назначение**: Флаг для включения анализа табличных частей
- **Значение по умолчанию**: `Истина`

### ВключатьКоманды
- **Тип**: Булево
- **Назначение**: Флаг для включения информации о командах формы
- **Значение по умолчанию**: `Истина`

### МаксимальнаяГлубинаВложенности
- **Тип**: Число, длина 2
- **Назначение**: Ограничение глубины вложенности при анализе групп
- **Значение по умолчанию**: `5`

### ВключатьНевидимыеЭлементы
- **Тип**: Булево
- **Назначение**: Флаг для включения невидимых элементов в результат
- **Значение по умолчанию**: `Ложь`

---

## 2. Структура форм

### Форма "Форма" (основная)

#### Реквизиты формы:

**РезультатСбора**
- **Тип**: Строка, неограниченная длина
- **Назначение**: Хранение результата в формате JSON

**СтатусСбора**
- **Тип**: Строка, длина 100
- **Назначение**: Текущий статус операции сбора

#### Элементы формы:

```
Форма (Форма)
├── ГруппаНастройки (Группа, обычная)
│   ├── ПутьКФайлуВыгрузки (ПолеВвода для ПутьКФайлуВыгрузки)
│   ├── КнопкаВыборФайла (КнопкаКоманды → ВыбратьФайл)
│   ├── ВключатьТабличныеЧасти (ПолеФлажка)
│   ├── ВключатьКоманды (ПолеФлажка)
│   ├── МаксимальнаяГлубинаВложенности (ПолеВвода)
│   └── ВключатьНевидимыеЭлементы (ПолеФлажка)
├── ГруппаДействия (Группа, командная панель)
│   ├── КнопкаСобратьКонтекст (КнопкаКоманды → СобратьКонтекстФормы)
│   └── КнопкаОчистить (КнопкаКоманды → Очистить)
├── СтатусСбора (ПолеНадписи)
└── РезультатСбора (ПолеТекстовогоДокумента, многострочное, только чтение)
```

---

## 3. Команды обработки

### СобратьКонтекстФормы
- **Действие**: `СобратьКонтекстФормыНаСервере`
- **Отображение**: Кнопка
- **Заголовок**: "Собрать контекст"
- **Картинка**: `БиблиотекаКартинок.Обновить`

### ВыбратьФайл
- **Действие**: `ВыбратьФайлНаКлиенте`
- **Отображение**: Кнопка
- **Заголовок**: "..."
- **Подсказка**: "Выбрать файл для сохранения"

### Очистить
- **Действие**: `ОчиститьНаСервере`
- **Отображение**: Кнопка
- **Заголовок**: "Очистить"

---

## 4. Модуль обработки (Ext/ObjectModule.bsl)

Этот модуль пока может быть пустым, вся логика будет в модуле формы.

---

## 5. Модуль формы (Forms/Форма/Ext/Form/Module.bsl)

### 5.1. Переменные модуля

```bsl
#Область ПеременныеМодуля

Перем ТестируемоеОкно;        // ТестируемоеОкноКлиентскогоПриложения
Перем ТестируемаяФорма;       // ТестируемаяФорма
Перем ТекущаяГлубина;         // Число - для отслеживания вложенности

#КонецОбласти
```

### 5.2. Обработчики событий формы

```bsl
#Область ОбработчикиСобытийФормы

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
    // Инициализация значений по умолчанию
    Если ПустаяСтрока(Объект.ПутьКФайлуВыгрузки) Тогда
        Объект.ПутьКФайлуВыгрузки = ПолучитьИмяВременногоФайла("json");
    КонецЕсли;
    
    СтатусСбора = "Готов к работе";
КонецПроцедуры

#КонецОбласти
```

### 5.3. Обработчики команд

```bsl
#Область ОбработчикиКоманд

&НаКлиенте
Процедура ВыбратьФайлНаКлиенте(Команда)
    // Диалог выбора файла
    Диалог = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Сохранение);
    Диалог.Заголовок = "Выберите файл для сохранения результата";
    Диалог.ПолноеИмяФайла = Объект.ПутьКФайлуВыгрузки;
    Диалог.Фильтр = "JSON файлы (*.json)|*.json";
    
    Если Диалог.Выбрать() Тогда
        Объект.ПутьКФайлуВыгрузки = Диалог.ПолноеИмяФайла;
    КонецЕсли;
КонецПроцедуры

&НаСервере
Процедура СобратьКонтекстФормыНаСервере()
    // Основная процедура сбора информации
    СтатусСбора = "Выполняется сбор...";
    
    Попытка
        // 1. Получение доступа к тестируемой форме
        ИнициализироватьТестируемуюФорму();
        
        // 2. Сбор информации о форме
        ДанныеФормы = СобратьИнформациюОФорме();
        
        // 3. Формирование JSON
        РезультатJSON = ПреобразоватьВJSON(ДанныеФормы);
        РезультатСбора = РезультатJSON;
        
        // 4. Сохранение в файл
        Если Не ПустаяСтрока(Объект.ПутьКФайлуВыгрузки) Тогда
            СохранитьВФайл(РезультатJSON);
        КонецЕсли;
        
        СтатусСбора = "Сбор завершен успешно";
        
    Исключение
        СтатусСбора = "Ошибка: " + ОписаниеОшибки();
        РезультатСбора = ОписаниеОшибки();
    КонецПопытки;
КонецПроцедуры

&НаСервере
Процедура ОчиститьНаСервере()
    РезультатСбора = "";
    СтатусСбора = "Готов к работе";
КонецПроцедуры

#КонецОбласти
```

### 5.4. Служебные процедуры и функции

```bsl
#Область СлужебныеПроцедурыИФункции

&НаСервере
Процедура ИнициализироватьТестируемуюФорму()
    // Получаем доступ к TestClient API
    ТестируемоеОкно = ВнешниеОбработки.СоздатьЭкземплярОбъекта(
        "<путь к vanessa-automation>"
    ).ПолучитьТестируемоеОкноКлиентскогоПриложения();
    
    // Получаем активную форму
    ТестируемаяФорма = ТестируемоеОкно.АктивноеОкно();
    
    Если ТестируемаяФорма = Неопределено Тогда
        ВызватьИсключение "Активная форма не найдена. Откройте нужную форму в клиенте тестирования.";
    КонецЕсли;
КонецПроцедуры

&НаСервере
Функция СобратьИнформациюОФорме()
    // Создаем структуру для хранения данных
    ДанныеФормы = Новый Структура;
    ДанныеФормы.Вставить("form_name", "");
    ДанныеФормы.Вставить("form_type", "");
    ДанныеФормы.Вставить("title", "");
    ДанныеФормы.Вставить("elements", Новый Массив);
    ДанныеФормы.Вставить("commands", Новый Массив);
    ДанныеФормы.Вставить("tables", Новый Массив);
    ДанныеФормы.Вставить("metadata", Новый Структура);
    
    // Основная информация о форме
    ДанныеФормы.form_name = Строка(ТестируемаяФорма.Имя);
    ДанныеФормы.title = Строка(ТестируемаяФорма.Заголовок);
    
    // Метаданные
    ДанныеФормы.metadata.Вставить("collected_at", ТекущаяДата());
    ДанныеФормы.metadata.Вставить("collector_version", "1.0.0");
    
    // Сбор элементов формы
    ТекущаяГлубина = 0;
    СобратьЭлементыФормы(ТестируемаяФорма, ДанныеФормы.elements);
    
    // Сбор табличных частей (если включено)
    Если Объект.ВключатьТабличныеЧасти Тогда
        СобратьТабличныеЧасти(ТестируемаяФорма, ДанныеФормы.tables);
    КонецЕсли;
    
    // Сбор команд (если включено)
    Если Объект.ВключатьКоманды Тогда
        СобратьКоманды(ТестируемаяФорма, ДанныеФормы.commands);
    КонецЕсли;
    
    Возврат ДанныеФормы;
КонецФункции

&НаСервере
Процедура СобратьЭлементыФормы(Форма, МассивЭлементов, ТекущийРодитель = Неопределено, Путь = "")
    // Проверка ограничения глубины
    ТекущаяГлубина = ТекущаяГлубина + 1;
    Если ТекущаяГлубина > Объект.МаксимальнаяГлубинаВложенности Тогда
        ТекущаяГлубина = ТекущаяГлубина - 1;
        Возврат;
    КонецЕсли;
    
    Попытка
        // Получаем коллекцию элементов
        Если ТекущийРодитель = Неопределено Тогда
            Элементы = Форма.ПолучитьЭлементы();
        Иначе
            Элементы = ТекущийРодитель.ПолучитьЭлементы();
        КонецЕсли;
        
        // Обход всех элементов
        Для Каждого Элемент Из Элементы Цикл
            // Пропуск невидимых элементов (если настройка выключена)
            Если Не Объект.ВключатьНевидимыеЭлементы И Не Элемент.Видимость Тогда
                Продолжить;
            КонецЕсли;
            
            // Создаем описание элемента
            ОписаниеЭлемента = СоздатьОписаниеЭлемента(Элемент, Путь);
            МассивЭлементов.Добавить(ОписаниеЭлемента);
            
            // Рекурсивный обход дочерних элементов для групп
            Если ЭлементЯвляетсяГруппой(Элемент) Тогда
                НовыйПуть = ?(ПустаяСтрока(Путь), Элемент.Имя, Путь + "." + Элемент.Имя);
                СобратьЭлементыФормы(Форма, ОписаниеЭлемента.children, Элемент, НовыйПуть);
            КонецЕсли;
        КонецЦикла;
        
    Исключение
        // Логирование ошибки при необходимости
    КонецПопытки;
    
    ТекущаяГлубина = ТекущаяГлубина - 1;
КонецПроцедуры

&НаСервере
Функция СоздатьОписаниеЭлемента(Элемент, Путь)
    // Создаем структуру для элемента
    Описание = Новый Структура;
    Описание.Вставить("name", Строка(Элемент.Имя));
    Описание.Вставить("type", ОпределитьТипЭлемента(Элемент));
    Описание.Вставить("title", ПолучитьЗаголовокЭлемента(Элемент));
    Описание.Вставить("path", ?(ПустаяСтрока(Путь), Элемент.Имя, Путь + "." + Элемент.Имя));
    Описание.Вставить("visible", Элемент.Видимость);
    Описание.Вставить("enabled", ПолучитьСвойствоДоступность(Элемент));
    Описание.Вставить("data_path", ПолучитьПутьКДанным(Элемент));
    
    // Дополнительные свойства в зависимости от типа
    ДобавитьСпецифичныеСвойства(Элемент, Описание);
    
    // Для групп - массив дочерних элементов
    Если ЭлементЯвляетсяГруппой(Элемент) Тогда
        Описание.Вставить("children", Новый Массив);
    КонецЕсли;
    
    Возврат Описание;
КонецФункции

&НаСервере
Функция ОпределитьТипЭлемента(Элемент)
    // Определяем тип элемента через его свойства
    Попытка
        ТипЭлемента = ТипЗнч(Элемент);
        ИмяТипа = Строка(ТипЭлемента);
        
        // Упрощенная типизация
        Если СтрНайти(ИмяТипа, "ПолеВвода") > 0 Тогда
            Возврат "input_field";
        ИначеЕсли СтрНайти(ИмяТипа, "Кнопка") > 0 Тогда
            Возврат "button";
        ИначеЕсли СтрНайти(ИмяТипа, "Таблица") > 0 Тогда
            Возврат "table";
        ИначеЕсли СтрНайти(ИмяТипа, "Группа") > 0 Тогда
            Возврат "group";
        ИначеЕсли СтрНайти(ИмяТипа, "Надпись") > 0 Тогда
            Возврат "label";
        ИначеЕсли СтрНайти(ИмяТипа, "Флажок") > 0 Тогда
            Возврат "checkbox";
        Иначе
            Возврат "other";
        КонецЕсли;
    Исключение
        Возврат "unknown";
    КонецПопытки;
КонецФункции

&НаСервере
Функция ПолучитьЗаголовокЭлемента(Элемент)
    Попытка
        Возврат Строка(Элемент.Заголовок);
    Исключение
        Возврат "";
    КонецПопытки;
КонецФункции

&НаСервере
Функция ПолучитьСвойствоДоступность(Элемент)
    Попытка
        Возврат Элемент.Доступность;
    Исключение
        Возврат Истина;
    КонецПопытки;
КонецФункции

&НаСервере
Функция ПолучитьПутьКДанным(Элемент)
    Попытка
        Возврат Строка(Элемент.ПутьКДанным);
    Исключение
        Возврат "";
    КонецПопытки;
КонецФункции

&НаСервере
Процедура ДобавитьСпецифичныеСвойства(Элемент, Описание)
    // Добавляем свойства в зависимости от типа элемента
    ТипЭлемента = Описание.type;
    
    Если ТипЭлемента = "input_field" Тогда
        Попытка
            Описание.Вставить("read_only", Элемент.ТолькоПросмотр);
        Исключение
        КонецПопытки;
        
    ИначеЕсли ТипЭлемента = "button" Тогда
        Попытка
            Описание.Вставить("command", Строка(Элемент.ИмяКоманды));
        Исключение
        КонецПопытки;
        
    ИначеЕсли ТипЭлемента = "table" Тогда
        Попытка
            Описание.Вставить("selection_mode", Строка(Элемент.РежимВыделения));
        Исключение
        КонецПопытки;
    КонецЕсли;
КонецПроцедуры

&НаСервере
Функция ЭлементЯвляетсяГруппой(Элемент)
    Попытка
        // Проверяем наличие метода получения дочерних элементов
        Элемент.ПолучитьЭлементы();
        Возврат Истина;
    Исключение
        Возврат Ложь;
    КонецПопытки;
КонецФункции

&НаСервере
Процедура СобратьТабличныеЧасти(Форма, МассивТаблиц)
    // Реализация сбора информации о табличных частях
    // TODO: будет реализовано на этапе 2
КонецПроцедуры

&НаСервере
Процедура СобратьКоманды(Форма, МассивКоманд)
    // Реализация сбора команд формы
    // TODO: будет реализовано на этапе 2
КонецПроцедуры

&НаСервере
Функция ПреобразоватьВJSON(Данные)
    // Используем встроенный сериализатор JSON
    ЗаписьJSON = Новый ЗаписьJSON;
    ЗаписьJSON.УстановитьСтроку(Новый ПараметрыЗаписиJSON(, Символы.Таб));
    ЗаписатьJSON(ЗаписьJSON, Данные);
    
    Возврат ЗаписьJSON.Закрыть();
КонецФункции

&НаСервере
Процедура СохранитьВФайл(ТекстJSON)
    ЗаписьТекста = Новый ЗаписьТекста(Объект.ПутьКФайлуВыгрузки, КодировкаТекста.UTF8);
    ЗаписьТекста.Записать(ТекстJSON);
    ЗаписьТекста.Закрыть();
КонецПроцедуры

#КонецОбласти
```

---

## 6. Порядок создания обработки в конфигураторе

1. **Создание новой внешней обработки**:
   - В конфигураторе: `Файл → Новый → Внешняя обработка`
   - Имя: `СборщикКонтекстаФорм`
   - Синоним: `Сборщик контекста форм`

2. **Добавление реквизитов**:
   - Добавить все реквизиты из раздела 1

3. **Создание формы**:
   - Добавить форму `Форма` с реквизитами и элементами из раздела 2
   - Настроить внешний вид и расположение элементов

4. **Добавление команд**:
   - Добавить команды из раздела 3

5. **Написание кода**:
   - Скопировать код модуля формы из раздела 5
   - При необходимости адаптировать под конкретную версию платформы

6. **Сохранение и выгрузка**:
   - Сохранить обработку
   - Выгрузить в файл: `FormContextCollector.epf`
   - Выгрузить исходники в XML: `Конфигурация → Выгрузить конфигурацию в файлы`

---

## 7. Зависимости и требования

### Обязательные:
- **1С:Предприятие 8.3** (версия 8.3.10 и выше)
- **Vanessa Automation** - должна быть доступна в конфигурации
- **Права доступа**: Возможность работы с внешними обработками

### Опциональные:
- **Для скриншотов (этап 3)**: Компонента для снятия скриншотов

---

## 8. Примечания для разработчика

1. **TestClient API**: Код использует API TestClient из Vanessa Automation. Убедитесь, что у вас установлена актуальная версия.

2. **Обработка ошибок**: В продакшн-версии необходимо добавить более детальную обработку ошибок.

3. **Производительность**: При работе с большими формами (>100 элементов) может потребоваться оптимизация.

4. **Кодировка**: Все текстовые данные должны сохраняться в UTF-8.

5. **Интеграция с Vanessa Automation**: 
   - Метод `ВнешниеОбработки.СоздатьЭкземплярОбъекта()` в коде является упрощением
   - В реальной реализации нужно будет получить ссылку на экземпляр Vanessa Automation через контекст менеджера тестирования

---

## 9. Структура выходных данных (JSON)

```json
{
  "form_name": "Документ.ЗаказПокупателя.Форма.ФормаДокумента",
  "form_type": "document_form",
  "title": "Заказ покупателя",
  "elements": [
    {
      "name": "Номер",
      "type": "input_field",
      "title": "Номер",
      "path": "Номер",
      "visible": true,
      "enabled": true,
      "data_path": "Объект.Номер",
      "read_only": true
    }
  ],
  "commands": [],
  "tables": [],
  "metadata": {
    "collected_at": "2024-01-15T10:30:00",
    "collector_version": "1.0.0"
  }
}
```

---

## 10. Следующие шаги после создания

После создания и выгрузки исходников обработки:

1. Поместить файл `FormContextCollector.epf` в директорию `tools/form-context/`
2. Выгрузить исходники XML в директорию `tools/form-context/src/`
3. Создать Python-скрипт для форматирования JSON → Markdown
4. Протестировать на реальных формах
5. Доработать функционал по результатам тестирования