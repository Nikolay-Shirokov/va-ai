////////////////////////////////////////////////////////////////////////////////
// Form Context Collector - Автономная версия
// Версия: 1.0.0
//
// Сбор контекста форм 1С без зависимости от Vanessa Automation
////////////////////////////////////////////////////////////////////////////////

#Область СлужебныеПеременныеМодуля

// Хранит параметры для асинхронной обработки в агентском режиме
&НаКлиенте
Перем ПараметрыОбработкиФормыАгента;

#КонецОбласти

#Область ОбработчикиСобытийФормы

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	// Инициализация на сервере (очистка лога, установка путей)
	ИнициализацияПриОткрытииНаСервере();
	
	Лог("=== Запуск обработки Form Context Collector ===");
	Лог("Версия: 1.0.0");
	
	// Проверка режима запуска (агентский/интерактивный)
	РежимРаботы = ПроверитьРежимЗапуска();
	Лог("Определён режим работы: " + РежимРаботы);
	
	Если РежимРаботы = "agent" Тогда
		// Агентский режим - автоматическое выполнение
		Лог("Переход в агентский режим");
		ВыполнитьАгентскийРежим();
	Иначе
		// Интерактивный режим - обновляем список форм
		Лог("Переход в интерактивный режим");
		ОбновитьСписокФорм();
	КонецЕсли;
	
	Лог("Инициализация завершена");
КонецПроцедуры

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	// Установка значений по умолчанию. Не используем здесь серверные вызовы.
	Объект.ВключатьНевидимыеЭлементы = Ложь;
	Объект.ГенерироватьMarkdown = Истина;
	Объект.МаксимальнаяГлубинаВложенности = 5;
	Объект.РежимОтладки = Истина; // Включаем для отладки
	
	СтатусСбора = "Готов к работе";
КонецПроцедуры

&НаСервере
Процедура ИнициализацияПриОткрытииНаСервере()
	// Очищаем лог при каждом открытии
	Если Объект.РежимОтладки Тогда
		ОчиститьЛог();
	КонецЕсли;
	
	// Определяем путь сохранения
	Объект.ПутьСохранения = ПолучитьПутьКонтекста();
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытийЭлементовФормы

&НаКлиенте
Процедура ПутьСохраненияНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	СтандартнаяОбработка = Ложь;
	
	Диалог = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.ВыборКаталога);
	Диалог.Заголовок = "Выберите каталог для сохранения результатов";
	Диалог.Каталог = Объект.ПутьСохранения;
	
	Если Диалог.Выбрать() Тогда
		Объект.ПутьСохранения = Диалог.Каталог;
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиКомандФормы

&НаКлиенте
Процедура ОбновитьСписокФорм(Команда = Неопределено)
	Лог("--- Обновление списка форм ---");
	СписокФорм.Очистить();
	СтатусСбора = "Обновление списка форм...";
	
	Попытка
		// Получаем список открытых форм
		Лог("Вызов ПолучитьСписокОткрытыхФорм()");
		МассивФорм = ПолучитьСписокОткрытыхФорм();
		Лог("Получено форм: " + Формат(МассивФорм.Количество(), "ЧГ="));
		
		// Заполняем таблицу
		Для Каждого ИнфоФормы Из МассивФорм Цикл
			НоваяСтрока = СписокФорм.Добавить();
			НоваяСтрока.Выбрано = Истина;
			НоваяСтрока.Заголовок = ИнфоФормы.Заголовок;
			НоваяСтрока.ПолноеИмяФормы = ИнфоФормы.ИмяФормы;
			НоваяСтрока.ВидОбъекта = ИнфоФормы.ВидОбъекта;
			НоваяСтрока.ТипФормы = ИнфоФормы.ТипФормы;
			НоваяСтрока.УИДФормы = ИнфоФормы.УИДФормы;
			
			Лог("  + " + ИнфоФормы.ИмяФормы + " (" + ИнфоФормы.Заголовок + "), УИД: " + ИнфоФормы.УИДФормы, "DEBUG");
		КонецЦикла;
		
		СтатусСбора = "Найдено форм: " + Формат(МассивФорм.Количество(), "ЧГ=");
		Лог("Обновление списка завершено успешно");
		
	Исключение
		СтатусСбора = "Ошибка получения списка форм: " + ОписаниеОшибки();
		Лог("ОШИБКА при обновлении списка: " + ОписаниеОшибки(), "ERROR");
		Лог("Подробно: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), "ERROR");
	КонецПопытки;
КонецПроцедуры

&НаКлиенте
Процедура СобратьКонтекст(Команда)
	Лог("=== Начало сбора контекста ===");
	СтатусСбора = "Выполняется сбор контекста...";
	РезультатСбора = "";
	
	Попытка
		// Получаем отмеченные формы
		ВыбранныеФормы = Новый Массив;
		Для Каждого Строка Из СписокФорм Цикл
			Если Строка.Выбрано Тогда
				ВыбранныеФормы.Добавить(Строка);
			КонецЕсли;
		КонецЦикла;
		
		Лог("Выбрано форм для обработки: " + Формат(ВыбранныеФормы.Количество(), "ЧГ="));
		
		Если ВыбранныеФормы.Количество() = 0 Тогда
			СтатусСбора = "Не выбрано ни одной формы";
			Лог("Прервано: не выбрано форм", "ERROR");
			Возврат;
		КонецЕсли;
		
		// Собираем контекст для каждой формы
		КоличествоУспешных = 0;
		КоличествоОшибок = 0;
		
		Для Каждого ВыбраннаяФорма Из ВыбранныеФормы Цикл
			Попытка
				Лог("--- Обработка формы: " + ВыбраннаяФорма.ПолноеИмяФормы);
				
				// Ищем форму по УИД среди открытых форм
				Лог("  Поиск формы по УИД: " + ВыбраннаяФорма.УИДФормы);
				СсылкаНаФорму = НайтиФормуПоУИД(ВыбраннаяФорма.УИДФормы);
				Если СсылкаНаФорму = Неопределено Тогда
					ВызватьИсключение "Форма с УИД " + ВыбраннаяФорма.УИДФормы + " не найдена или была закрыта";
				КонецЕсли;
				
				// Сбор данных формы
				Лог("  Сбор информации о форме...");
				ДанныеФормы = СобратьИнформациюОФорме(СсылкаНаФорму);
				Лог("  Собрано элементов: " + Формат(ДанныеФормы.elements.Количество(), "ЧГ="));
				
				// Генерация JSON
				Лог("  Генерация JSON...");
				ТекстJSON = ПреобразоватьВJSON(ДанныеФормы);
				
				// Сохранение JSON
				ИмяФайлаJSON = СформироватьИмяФайла(ДанныеФормы.form_name) + ".json";
				ПутьJSON = Объект.ПутьСохранения + ИмяФайлаJSON;
				Лог("  Сохранение JSON: " + ПутьJSON);
				СохранитьВФайл(ТекстJSON, ПутьJSON);
				
				// Генерация Markdown (если включено)
				Если Объект.ГенерироватьMarkdown Тогда
					Лог("  Генерация Markdown v2.0...");
					ТекстMarkdown = СгенерироватьMarkdownНовыйФормат(СсылкаНаФорму);
					ИмяФайлаMD = СформироватьИмяФайла(ДанныеФормы.form_name) + ".md";
					ПутьMD = Объект.ПутьСохранения + ИмяФайлаMD;
					Лог("  Сохранение Markdown: " + ПутьMD);
					СохранитьВФайл(ТекстMarkdown, ПутьMD);
				КонецЕсли;
				
				// Обновление индекса
				Лог("  Обновление index.json...");
				ОбновитьИндексФорм(ДанныеФормы, ИмяФайлаJSON);
				
				КоличествоУспешных = КоличествоУспешных + 1;
				РезультатСбора = РезультатСбора + "✓ " + ДанныеФормы.form_name + Символы.ПС;
				Лог("  ✓ Форма обработана успешно");
				
			Исключение
				КоличествоОшибок = КоличествоОшибок + 1;
				ТекстОшибки = ОписаниеОшибки();
				РезультатСбора = РезультатСбора + "✗ " + ВыбраннаяФорма.ПолноеИмяФормы +
					": " + ТекстОшибки + Символы.ПС;
				Лог("  ✗ ОШИБКА: " + ТекстОшибки, "ERROR");
				Лог("  Подробно: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), "ERROR");
			КонецПопытки;
		КонецЦикла;
		
		СтатусСбора = СтрШаблон("Сбор завершен. Успешно: %1, Ошибок: %2",
			КоличествоУспешных, КоличествоОшибок);
		Лог("=== Сбор контекста завершён. Успешно: " + Формат(КоличествоУспешных, "ЧГ=") +
			", Ошибок: " + Формат(КоличествоОшибок, "ЧГ=") + " ===");
		
	Исключение
		СтатусСбора = "Ошибка сбора контекста: " + ОписаниеОшибки();
		РезультатСбора = РезультатСбора + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Лог("КРИТИЧЕСКАЯ ОШИБКА при сборе контекста: " + ОписаниеОшибки(), "ERROR");
		Лог("Стек: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), "ERROR");
	КонецПопытки;
КонецПроцедуры

&НаКлиенте
Процедура Очистить(Команда)
	РезультатСбора = "";
	СтатусСбора = "Готов к работе";
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область РаботаСФормами

// Получает список открытых форм в приложении
//
// Возвращаемое значение:
//   Массив из Структура - Массив с информацией о формах
//
&НаКлиенте
Функция ПолучитьСписокОткрытыхФорм()
	МассивНайденныхФорм = Новый Массив;
	
	// Получаем УИД текущей формы, чтобы исключить её из списка
	УИДТекущейФормы = Строка(ЭтаФорма.УникальныйИдентификатор);
	Лог("  УИД текущей формы: " + УИДТекущейФормы, "DEBUG");
	
	// Получаем все окна приложения
	КоллекцияОкон = ПолучитьОкна();
	
	Если КоллекцияОкон = Неопределено Тогда
		Возврат МассивНайденныхФорм;
	КонецЕсли;
	
	// Обходим все окна
	Для Каждого ТекущееОкно Из КоллекцияОкон Цикл
		Попытка
			// Получаем формы в окне
			МассивФормОкна = ТекущееОкно.Содержимое;
			
			Для Каждого ТекущаяФорма Из МассивФормОкна Цикл
				Попытка
					// Получаем встроенный УникальныйИдентификатор формы
					УИДФормы = Строка(ТекущаяФорма.УникальныйИдентификатор);
					
					ИнфоФормы = Новый Структура;
					ИнфоФормы.Вставить("Заголовок", ПолучитьЗаголовокФормы(ТекущаяФорма));
					ИнфоФормы.Вставить("ИмяФормы", ПолучитьПолноеИмяФормы(ТекущаяФорма));
					ИнфоФормы.Вставить("ВидОбъекта", ПолучитьВидОбъекта(ТекущаяФорма));
					ИнфоФормы.Вставить("ТипФормы", ПолучитьТипФормы(ТекущаяФорма));
					ИнфоФормы.Вставить("УИДФормы", УИДФормы);
					
					// Пропускаем текущую форму обработки по УИД
					Если УИДФормы = УИДТекущейФормы Тогда
						Лог("  Пропущена текущая форма обработки (УИД: " + УИДФормы + ")", "DEBUG");
						Продолжить;
					КонецЕсли;
					
					МассивНайденныхФорм.Добавить(ИнфоФормы);
				Исключение
					Лог("  Пропущена форма из-за ошибки: " + ОписаниеОшибки(), "DEBUG");
				КонецПопытки;
			КонецЦикла;
		Исключение
			Лог("  Пропущено окно из-за ошибки: " + ОписаниеОшибки(), "DEBUG");
		КонецПопытки;
	КонецЦикла;
	
	Возврат МассивНайденныхФорм;
КонецФункции

// Получает заголовок формы
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - Форма
//
// Возвращаемое значение:
//   Строка - Заголовок формы
//
&НаКлиенте
Функция ПолучитьЗаголовокФормы(Форма)
	Попытка
		ЗаголовокФормы = "";
		
		// Способ 1: через свойство Заголовок
		Попытка
			ЗаголовокФормы = Строка(Форма.Заголовок);
		Исключение
			Лог("    Не удалось получить Форма.Заголовок: " + ОписаниеОшибки(), "DEBUG");
		КонецПопытки;
		
		// Способ 2: через преобразование формы в строку
		Если ПустаяСтрока(ЗаголовокФормы) Тогда
			Попытка
				ЗаголовокФормы = Строка(Форма);
			Исключение
				Лог("    Не удалось получить Строка(Форма): " + ОписаниеОшибки(), "DEBUG");
			КонецПопытки;
		КонецЕсли;
		
		Если ПустаяСтрока(ЗаголовокФормы) Тогда
			Возврат "Без заголовка";
		Иначе
			Возврат ЗаголовокФормы;
		КонецЕсли;
	Исключение
		Лог("    Критическая ошибка получения заголовка: " + ОписаниеОшибки(), "ERROR");
		Возврат "Без заголовка";
	КонецПопытки;
КонецФункции

// Получает полное имя формы
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - Форма
//
// Возвращаемое значение:
//   Строка - Полное имя формы
//
&НаКлиенте
Функция ПолучитьПолноеИмяФормы(Форма)
	ПолноеИмя = "";
	
	// Способ 1: через свойство ИмяФормы (основной способ)
	Попытка
		ПолноеИмя = Форма.ИмяФормы;
		Если Не ПустаяСтрока(ПолноеИмя) Тогда
			Возврат ПолноеИмя;
		КонецЕсли;
	Исключение
		Лог("    Не удалось получить Форма.ИмяФормы: " + ОписаниеОшибки(), "DEBUG");
	КонецПопытки;
	
	// Способ 2: через ИмяМетаданных
	Попытка
		ПолноеИмя = Форма.ИмяМетаданных;
		Если Не ПустаяСтрока(ПолноеИмя) Тогда
			Возврат ПолноеИмя;
		КонецЕсли;
	Исключение
		Лог("    Не удалось получить Форма.ИмяМетаданных: " + ОписаниеОшибки(), "DEBUG");
	КонецПопытки;
	
	// Способ 3: через ИмяОбъектаМетаданных
	Попытка
		ПолноеИмя = Форма.ИмяОбъектаМетаданных;
		Если Не ПустаяСтрока(ПолноеИмя) Тогда
			Возврат ПолноеИмя;
		КонецЕсли;
	Исключение
		Лог("    Не удалось получить Форма.ИмяОбъектаМетаданных: " + ОписаниеОшибки(), "DEBUG");
	КонецПопытки;
	
	// Если не удалось получить имя, возвращаем заголовок
	Лог("    Не удалось получить имя формы ни одним способом, используем заголовок", "DEBUG");
	Возврат ПолучитьЗаголовокФормы(Форма);
КонецФункции

// Определяет вид объекта по имени формы
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - Форма
//
// Возвращаемое значение:
//   Строка - Вид объекта (Документ, Справочник и т.д.)
//
&НаКлиенте
Функция ПолучитьВидОбъекта(Форма)
	Попытка
		ИмяФормы = Строка(Форма.ИмяФормы);
		
		Если СтрНайти(ИмяФормы, "Документ.") = 1 Тогда
			Возврат "Документ";
		ИначеЕсли СтрНайти(ИмяФормы, "Справочник.") = 1 Тогда
			Возврат "Справочник";
		ИначеЕсли СтрНайти(ИмяФормы, "Отчет.") = 1 Тогда
			Возврат "Отчет";
		ИначеЕсли СтрНайти(ИмяФормы, "Обработка.") = 1 Тогда
			Возврат "Обработка";
		ИначеЕсли СтрНайти(ИмяФормы, "РегистрСведений.") = 1 Тогда
			Возврат "РегистрСведений";
		ИначеЕсли СтрНайти(ИмяФормы, "РегистрНакопления.") = 1 Тогда
			Возврат "РегистрНакопления";
		ИначеЕсли СтрНайти(ИмяФормы, "ОбщаяФорма.") = 1 Тогда
			Возврат "ОбщаяФорма";
		КонецЕсли;
	Исключение
		// Игнорируем ошибку - функция вернет "Прочее" по умолчанию
		Лог("  Ошибка определения вида объекта: " + ОписаниеОшибки(), "DEBUG");
	КонецПопытки;
	
	Возврат "Прочее";
КонецФункции

// Ищет форму по УникальномуИдентификатору среди открытых форм
//
// Параметры:
//   УИДФормы - Строка - УникальныйИдентификатор формы
//
// Возвращаемое значение:
//   ФормаКлиентскогоПриложения, Неопределено - Найденная форма или Неопределено
//
&НаКлиенте
Функция НайтиФормуПоУИД(УИДФормы)
	// Получаем все окна приложения
	КоллекцияОкон = ПолучитьОкна();
	
	Если КоллекцияОкон = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Обходим все окна
	Для Каждого ТекущееОкно Из КоллекцияОкон Цикл
		Попытка
			// Получаем формы в окне
			МассивФормОкна = ТекущееОкно.Содержимое;
			
			Для Каждого ТекущаяФорма Из МассивФормОкна Цикл
				Попытка
					// Проверяем совпадение УИД
					Если Строка(ТекущаяФорма.УникальныйИдентификатор) = УИДФормы Тогда
						Возврат ТекущаяФорма;
					КонецЕсли;
				Исключение
					Лог("  Ошибка при проверке УИД формы: " + ОписаниеОшибки(), "DEBUG");
				КонецПопытки;
			КонецЦикла;
		Исключение
			Лог("  Ошибка при обработке окна: " + ОписаниеОшибки(), "DEBUG");
		КонецПопытки;
	КонецЦикла;
	
	Возврат Неопределено;
КонецФункции

// Определяет тип формы по её имени
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - Форма
//
// Возвращаемое значение:
//   Строка - Тип формы (ФормаДокумента, ФормаСписка и т.д.)
//
&НаКлиенте
Функция ПолучитьТипФормы(Форма)
	Попытка
		ИмяФормы = Строка(Форма.ИмяФормы);
		
		// Извлекаем последнюю часть после последней точки
		МассивЧастей = СтрРазделить(ИмяФормы, ".", Ложь);
		Если МассивЧастей.Количество() > 0 Тогда
			ТипФормы = МассивЧастей[МассивЧастей.Количество() - 1];
			Возврат ТипФормы;
		КонецЕсли;
	Исключение
		// Игнорируем ошибку - функция вернет "ПроизвольнаяФорма" по умолчанию
		Лог("  Ошибка определения типа формы: " + ОписаниеОшибки(), "DEBUG");
	КонецПопытки;
	
	Возврат "ПроизвольнаяФорма";
КонецФункции

#КонецОбласти

#Область СборКонтекста

// Собирает информацию о форме и её элементах
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - Форма для сбора контекста
//
// Возвращаемое значение:
//   Структура - Данные о форме
//
&НаКлиенте
Функция СобратьИнформациюОФорме(Форма)
	// Создаем структуру для хранения данных
	ДанныеФормы = Новый Структура;
	ДанныеФормы.Вставить("form_name", ПолучитьПолноеИмяФормы(Форма));
	ДанныеФормы.Вставить("form_type", ОпределитьТипФормыПоИмени(ДанныеФормы.form_name));
	ДанныеФормы.Вставить("title", ПолучитьЗаголовокФормы(Форма));
	ДанныеФормы.Вставить("elements", Новый Массив);
	
	// Служебная информация
	СлужебнаяИнформация = Новый Структура;
	// На клиенте используем ТекущаяДата(), т.к. ТекущаяДатаСеанса() недоступна
	//BSLLS:DeprecatedMethods-off
	СлужебнаяИнформация.Вставить("collected_at", ТекущаяДатаСеанса());
	//BSLLS:DeprecatedMethods-on
	СлужебнаяИнформация.Вставить("collector_version", "1.0.0");
	СлужебнаяИнформация.Вставить("max_depth", Объект.МаксимальнаяГлубинаВложенности);
	СлужебнаяИнформация.Вставить("include_invisible", Объект.ВключатьНевидимыеЭлементы);
	СлужебнаяИнформация.Вставить("detail_level", "minimal");
	ДанныеФормы.Вставить("metadata", СлужебнаяИнформация);
	
	// Используем свойство ПодчиненныеЭлементы формы, которое содержит только корневые элементы
	// Форма.Элементы содержит ВСЕ элементы плоским списком (включая вложенные)
	// Форма.ПодчиненныеЭлементы содержит только элементы верхнего уровня
	Попытка
		КоллекцияКорневых = Форма.ПодчиненныеЭлементы;
		Лог("  Найдено корневых элементов: " + Формат(КоллекцияКорневых.Количество(), "ЧГ="), "DEBUG");
		
		// Сбор элементов формы (передаем коллекцию корневых элементов)
		СобратьЭлементыФормы(КоллекцияКорневых, ДанныеФормы.elements, 0);
	Исключение
		Лог("  Критическая ошибка сбора элементов: " + ОписаниеОшибки(), "ERROR");
	КонецПопытки;
	
	// Дополнительно обрабатываем автоматическую командную панель формы
	// Она не входит в ПодчиненныеЭлементы, но содержит важные кнопки
	// Обращаемся к ней по имени через Элементы
	Попытка
		// Стандартное имя автоматической командной панели
		ЭлементКП = Форма.Элементы.ФормаКоманднаяПанель;
		
		Лог("  Обработка командной панели формы", "DEBUG");
		
		// ЭлементКП - это ГруппаФормы, обрабатываем как обычный элемент
		ОписаниеКП = СоздатьОписаниеЭлемента(ЭлементКП, 0);
		Если ОписаниеКП <> Неопределено Тогда
			ДанныеФормы.elements.Добавить(ОписаниеКП);
			Лог("  ✓ Командная панель формы добавлена", "DEBUG");
		КонецЕсли;
	Исключение
		// Командная панель может отсутствовать или иметь другое имя
		Лог("  Командная панель формы не найдена: " + ОписаниеОшибки(), "DEBUG");
	КонецПопытки;
	
	Возврат ДанныеФормы;
КонецФункции

// Определяет тип формы по её имени для JSON
//
// Параметры:
//   ИмяФормы - Строка - Полное имя формы
//
// Возвращаемое значение:
//   Строка - Тип формы на английском
//
&НаКлиенте
Функция ОпределитьТипФормыПоИмени(ИмяФормы)
	Если СтрНайти(ИмяФормы, "Документ.") > 0 Тогда
		Возврат "document_form";
	ИначеЕсли СтрНайти(ИмяФормы, "Справочник.") > 0 Тогда
		Возврат "catalog_form";
	ИначеЕсли СтрНайти(ИмяФормы, "Обработка.") > 0 Тогда
		Возврат "data_processor_form";
	ИначеЕсли СтрНайти(ИмяФормы, "Отчет.") > 0 Тогда
		Возврат "report_form";
	ИначеЕсли СтрНайти(ИмяФормы, "РегистрСведений.") > 0 Тогда
		Возврат "information_register_form";
	Иначе
		Возврат "other_form";
	КонецЕсли;
КонецФункции

// Собирает элементы формы рекурсивно (дерево)
//
// Параметры:
//   КоллекцияЭлементов - ЭлементыФормы, ПодчиненныеЭлементы - Коллекция элементов
//   МассивЭлементов - Массив - Массив для добавления элементов
//   ТекущаяГлубина - Число - Текущая глубина рекурсии
//
&НаКлиенте
Процедура СобратьЭлементыФормы(КоллекцияЭлементов, МассивЭлементов, ТекущаяГлубина)
	// Проверка ограничения глубины
	Если ТекущаяГлубина >= Объект.МаксимальнаяГлубинаВложенности Тогда
		Лог(СтрШаблон("    [Глубина %1] Достигнута максимальная глубина", ТекущаяГлубина), "DEBUG");
		Возврат;
	КонецЕсли;
	
	Попытка
		КоллВсего = КоллекцияЭлементов.Количество();
		Лог(СтрШаблон("  [Глубина %1] Начало обработки %2 элементов", ТекущаяГлубина, КоллВсего), "DEBUG");
		
		Для Каждого Элемент Из КоллекцияЭлементов Цикл
			Попытка
				ИмяЭлемента = ПолучитьСвойствоЭлемента(Элемент, "Имя");
				
				// Проверка видимости (только для элементов с этим свойством)
				Если Не Объект.ВключатьНевидимыеЭлементы Тогда
					Попытка
						Если Не Элемент.Видимость Тогда
							Лог(СтрШаблон("    [Глубина %1] Пропущен невидимый: %2", ТекущаяГлубина, ИмяЭлемента), "DEBUG");
							Продолжить;
						КонецЕсли;
					Исключение
						// Свойство Видимость недоступно для некоторых элементов (расширенные подсказки)
						// Пропускаем такие элементы
						Лог(СтрШаблон("    [Глубина %1] Пропущен (нет Видимость): %2", ТекущаяГлубина, ИмяЭлемента), "DEBUG");
						Продолжить;
					КонецПопытки;
				КонецЕсли;
				
				// Создаем описание элемента
				Лог(СтрШаблон("    [Глубина %1] Обрабатываю: %2", ТекущаяГлубина, ИмяЭлемента), "DEBUG");
				ОписаниеЭлемента = СоздатьОписаниеЭлемента(Элемент, ТекущаяГлубина);
				Если ОписаниеЭлемента <> Неопределено Тогда
					МассивЭлементов.Добавить(ОписаниеЭлемента);
					
					// Логируем результат
					ЕстьДочерние = ОписаниеЭлемента.Свойство("children");
					Если ЕстьДочерние Тогда
						Лог(СтрШаблон("    [Глубина %1] ✓ Добавлен %2 (type=%3) с %4 детьми",
							ТекущаяГлубина, ИмяЭлемента, ОписаниеЭлемента.type, ОписаниеЭлемента.children.Количество()), "DEBUG");
					Иначе
						Лог(СтрШаблон("    [Глубина %1] ✓ Добавлен %2 (type=%3) без детей",
							ТекущаяГлубина, ИмяЭлемента, ОписаниеЭлемента.type), "DEBUG");
					КонецЕсли;
				Иначе
					Лог(СтрШаблон("    [Глубина %1] × Пропущен: %2 (skip)", ТекущаяГлубина, ИмяЭлемента), "DEBUG");
				КонецЕсли;
				
			Исключение
				Лог(СтрШаблон("    [Глубина %1] ОШИБКА при обработке элемента: %2", ТекущаяГлубина, ОписаниеОшибки()), "ERROR");
			КонецПопытки;
		КонецЦикла;
		
		Лог(СтрШаблон("  [Глубина %1] Завершено. Добавлено в массив: %2", ТекущаяГлубина, МассивЭлементов.Количество()), "DEBUG");
		
	Исключение
		Лог("  Ошибка при получении элементов: " + ОписаниеОшибки(), "ERROR");
	КонецПопытки;
КонецПроцедуры

// Создает минимальное описание элемента для AI
//
// Параметры:
//   Элемент - ЭлементФормы - Элемент формы
//   ТекущаяГлубина - Число - Текущая глубина для рекурсии
//
// Возвращаемое значение:
//   Структура, Неопределено - Описание элемента или Неопределено для пропуска
//
&НаКлиенте
Функция СоздатьОписаниеЭлемента(Элемент, ТекущаяГлубина)
	ИмяЭлемента = ПолучитьСвойствоЭлемента(Элемент, "Имя");
	ТипЭлемента = ОпределитьТипЭлемента(Элемент);
	
	Лог(СтрШаблон("      [Глубина %1] СоздатьОписание: %2, тип = %3", ТекущаяГлубина, ИмяЭлемента, ТипЗнч(Элемент)), "DEBUG");
	
	// Пропускаем служебные элементы (контекстные меню, расширенные подсказки)
	Если ТипЭлемента = "skip" Тогда
		Лог(СтрШаблон("      [Глубина %1] %2 пропущен (skip)", ТекущаяГлубина, ИмяЭлемента), "DEBUG");
		Возврат Неопределено;
	КонецЕсли;
	
	// Минимальная структура для AI
	Описание = Новый Структура;
	Описание.Вставить("name", ИмяЭлемента);
	Описание.Вставить("type", ТипЭлемента);
	
	// Заголовок (только если не пустой)
	Заголовок = ПолучитьСвойствоЭлемента(Элемент, "Заголовок");
	Если Не ПустаяСтрока(Заголовок) Тогда
		Описание.Вставить("title", Заголовок);
	КонецЕсли;
	
	// Для полей - добавляем Вид
	Если ТипЭлемента = "field" Тогда
		ВидПоля = ПолучитьВидПоля(Элемент);
		Если Не ПустаяСтрока(ВидПоля) Тогда
			Описание.Вставить("kind", ВидПоля);
		КонецЕсли;
	КонецЕсли;
	
	// Рекурсивно собираем подчиненные элементы
	// У ГруппаФормы и ТаблицаФормы есть ПодчиненныеЭлементы на клиенте
	Если ТипЭлемента = "group" Или ТипЭлемента = "table" Тогда
		МассивДочерних = Новый Массив;
		
		// 1. Собираем ПодчиненныеЭлементы
		Попытка
			КоллекцияПодчиненных = Элемент.ПодчиненныеЭлементы;
			КоличествоПодчиненных = КоллекцияПодчиненных.Количество();
			
			Лог(СтрШаблон("      [Глубина %1] %2 (%3): найдено %4 подчиненных",
				ТекущаяГлубина, ИмяЭлемента, ТипЭлемента, КоличествоПодчиненных), "DEBUG");
			
			Если КоличествоПодчиненных > 0 Тогда
				Лог(СтрШаблон("      [Глубина %1] %2: запуск рекурсии (ПодчиненныеЭлементы)...", ТекущаяГлубина, ИмяЭлемента), "DEBUG");
				СобратьЭлементыФормы(КоллекцияПодчиненных, МассивДочерних, ТекущаяГлубина + 1);
			КонецЕсли;
		Исключение
			Лог(СтрШаблон("      [Глубина %1] %2: ОШИБКА доступа к ПодчиненныеЭлементы: %3",
				ТекущаяГлубина, ИмяЭлемента, ОписаниеОшибки()), "ERROR");
		КонецПопытки;
		
		// 2. Собираем КоманднаяПанель (если есть)
		// У таблиц и групп может быть командная панель с кнопками
		// Доступ к ней через имя: <ИмяЭлемента>КоманднаяПанель
		Попытка
			// Формируем стандартное имя командной панели
			ИмяКП = ИмяЭлемента + "КоманднаяПанель";
			
			// Ищем командную панель в ПодчиненныеЭлементы
			Для Каждого ПодчиненныйЭлемент Из Элемент.ПодчиненныеЭлементы Цикл
				Если ПолучитьСвойствоЭлемента(ПодчиненныйЭлемент, "Имя") = ИмяКП Тогда
					Лог(СтрШаблон("      [Глубина %1] %2: найдена командная панель", ТекущаяГлубина, ИмяЭлемента), "DEBUG");
					
					// Обрабатываем элементы командной панели
					Попытка
						КоллекцияКП = ПодчиненныйЭлемент.ПодчиненныеЭлементы;
						Если КоллекцияКП.Количество() > 0 Тогда
							Лог(СтрШаблон("      [Глубина %1] %2: запуск рекурсии (КоманднаяПанель, %3 элементов)...",
								ТекущаяГлубина, ИмяЭлемента, КоллекцияКП.Количество()), "DEBUG");
							СобратьЭлементыФормы(КоллекцияКП, МассивДочерних, ТекущаяГлубина + 1);
						КонецЕсли;
					Исключение
						Лог(СтрШаблон("      [Глубина %1] %2: ОШИБКА обработки КоманднаяПанель: %3",
							ТекущаяГлубина, ИмяЭлемента, ОписаниеОшибки()), "DEBUG");
					КонецПопытки;
					
					Прервать; // Нашли командную панель, выходим из цикла
				КонецЕсли;
			КонецЦикла;
		Исключение
			// Ошибка поиска командной панели - не критично
			Лог(СтрШаблон("      [Глубина %1] %2: ошибка поиска командной панели: %3",
				ТекущаяГлубина, ИмяЭлемента, ОписаниеОшибки()), "DEBUG");
		КонецПопытки;
		
		// Добавляем собранные дочерние элементы
		Если МассивДочерних.Количество() > 0 Тогда
			Описание.Вставить("children", МассивДочерних);
			Лог(СтрШаблон("      [Глубина %1] %2: ✓ добавлено children[] с %3 элементами",
				ТекущаяГлубина, ИмяЭлемента, МассивДочерних.Количество()), "DEBUG");
		Иначе
			Лог(СтрШаблон("      [Глубина %1] %2: массив дочерних пуст после обработки",
				ТекущаяГлубина, ИмяЭлемента), "DEBUG");
		КонецЕсли;
	Иначе
		Лог(СтрШаблон("      [Глубина %1] %2 (%3): тип не имеет подчиненных",
			ТекущаяГлубина, ИмяЭлемента, ТипЭлемента), "DEBUG");
	КонецЕсли;
	
	Возврат Описание;
КонецФункции

// Определяет тип элемента формы (правильная проверка через Тип())
//
// Параметры:
//   Элемент - ЭлементФормы - Элемент для анализа
//
// Возвращаемое значение:
//   Строка - Тип элемента для AI: "field", "button", "table", "group", "skip"
//
&НаКлиенте
Функция ОпределитьТипЭлемента(Элемент)
	Попытка
		ТипЭлемента = ТипЗнч(Элемент);
		
		// Поля формы
		Если ТипЭлемента = Тип("ПолеФормы") Тогда
			Возврат "field";
			
		// Кнопки
		ИначеЕсли ТипЭлемента = Тип("КнопкаФормы") Тогда
			Возврат "button";
			
		// Таблицы
		ИначеЕсли ТипЭлемента = Тип("ТаблицаФормы") Тогда
			Возврат "table";
			
		// Группы
		ИначеЕсли ТипЭлемента = Тип("ГруппаФормы") Тогда
			Возврат "group";
			
		// Пропускаем служебные элементы
		ИначеЕсли ТипЭлемента = Тип("ДополнениеЭлементаФормы") Тогда
			Возврат "skip";
			
		// Другие типы - пропускаем
		Иначе
			Возврат "skip";
		КонецЕсли;
		
	Исключение
		Возврат "skip";
	КонецПопытки;
КонецФункции

// Получает вид поля формы
//
// Параметры:
//   ПолеФормы - ПолеФормы - Поле формы
//
// Возвращаемое значение:
//   Строка - Вид поля (input, checkbox, picture и т.д.)
//
&НаКлиенте
Функция ПолучитьВидПоля(ПолеФормы)
	Попытка
		ВидПоля = ПолеФормы.Вид;
		
		// Преобразуем перечисление в строку для JSON
		Если ВидПоля = ВидПоляФормы.ПолеВвода Тогда
			Возврат "input";
		ИначеЕсли ВидПоля = ВидПоляФормы.ПолеФлажка Тогда
			Возврат "checkbox";
		ИначеЕсли ВидПоля = ВидПоляФормы.ПолеКартинки Тогда
			Возврат "picture";
		ИначеЕсли ВидПоля = ВидПоляФормы.ПолеНадписи Тогда
			Возврат "label";
		ИначеЕсли ВидПоля = ВидПоляФормы.ПолеПереключателя Тогда
			Возврат "radio";
		Иначе
			Возврат "other";
		КонецЕсли;
		
	Исключение
		Возврат "";
	КонецПопытки;
КонецФункции

// Безопасно получает свойство элемента
//
// Параметры:
//   Элемент - ЭлементФормы - Элемент
//   ИмяСвойства - Строка - Имя свойства
//
// Возвращаемое значение:
//   Произвольный - Значение свойства
//
&НаКлиенте
Функция ПолучитьСвойствоЭлемента(Элемент, ИмяСвойства)
	Попытка
		Возврат Элемент[ИмяСвойства];
	Исключение
		Возврат "";
	КонецПопытки;
КонецФункции

#Область МаппингТиповДляMarkdownV2

// Определяет тег элемента для Markdown v2.0
//
// Параметры:
//   Элемент - ЭлементФормы - Элемент формы
//   РодительЭлемент - ЭлементФормы - Родительский элемент (для определения контекста)
//
// Возвращаемое значение:
//   Строка - Тег элемента для AI ([Input], [Button], [Table] и т.д.) или "skip"
//
&НаКлиенте
Функция ОпределитьТегЭлемента(Элемент, РодительЭлемент = Неопределено)
	Попытка
		ТипЭлемента = ТипЗнч(Элемент);
		
		// Поля формы
		Если ТипЭлемента = Тип("ПолеФормы") Тогда
			// Проверяем, находится ли поле внутри таблицы
			Если РодительЭлемент <> Неопределено И ТипЗнч(РодительЭлемент) = Тип("ТаблицаФормы") Тогда
				Возврат "Col";
			Иначе
				Возврат ОпределитьТегПоля(Элемент);
			КонецЕсли;
			
		// Кнопки
		ИначеЕсли ТипЭлемента = Тип("КнопкаФормы") Тогда
			Возврат "Button";
			
		// Таблицы
		ИначеЕсли ТипЭлемента = Тип("ТаблицаФормы") Тогда
			Возврат "Table";
			
		// Группы
		ИначеЕсли ТипЭлемента = Тип("ГруппаФормы") Тогда
			Возврат ОпределитьТегГруппы(Элемент);
			
		// Декорации
		ИначеЕсли ТипЭлемента = Тип("ДекорацияФормы") Тогда
			Возврат ОпределитьТегДекорации(Элемент);
			
		// Служебные элементы (пропускаем)
		ИначеЕсли ТипЭлемента = Тип("ДополнениеЭлементаФормы") Тогда
			Возврат "skip";
			
		// Неизвестные типы - пропускаем
		Иначе
			Возврат "skip";
		КонецЕсли;
		
	Исключение
		Возврат "skip";
	КонецПопытки;
КонецФункции

// Определяет тег для поля формы на основе его вида
//
// Параметры:
//   ПолеФормы - ПолеФормы - Поле формы
//
// Возвращаемое значение:
//   Строка - Тег поля ([Input], [Checkbox], [Radio] и т.д.)
//
&НаКлиенте
Функция ОпределитьТегПоля(ПолеФормы)
	Попытка
		ВидПоля = ПолеФормы.Вид;
		
		// Маппинг видов полей на теги
		Если ВидПоля = ВидПоляФормы.ПолеВвода Тогда
			Возврат "Input";
		ИначеЕсли ВидПоля = ВидПоляФормы.ПолеФлажка Тогда
			Возврат "Checkbox";
		ИначеЕсли ВидПоля = ВидПоляФормы.ПолеПереключателя Тогда
			Возврат "Radio";
		ИначеЕсли ВидПоля = ВидПоляФормы.ПолеНадписи Тогда
			Возврат "Label";
		ИначеЕсли ВидПоля = ВидПоляФормы.ПолеКартинки Тогда
			Возврат "Image";
		ИначеЕсли ВидПоля = ВидПоляФормы.ПолеТекстовогоДокумента Тогда
			Возврат "TextEditor";
		ИначеЕсли ВидПоля = ВидПоляФормы.ПолеHTMLДокумента Тогда
			Возврат "HTML";
		ИначеЕсли ВидПоля = ВидПоляФормы.ПолеТабличногоДокумента Тогда
			Возврат "Spreadsheet";
		ИначеЕсли ВидПоля = ВидПоляФормы.ПолеКалендаря Тогда
			Возврат "Calendar";
		Иначе
			// Для неизвестных видов возвращаем Input по умолчанию
			Возврат "Input";
		КонецЕсли;
		
	Исключение
		// При ошибке возвращаем Input по умолчанию
		Возврат "Input";
	КонецПопытки;
КонецФункции

// Определяет тег для группы формы на основе её вида
//
// Параметры:
//   ГруппаФормы - ГруппаФормы - Группа формы
//
// Возвращаемое значение:
//   Строка - Тег группы ([Group], [Tab], [Menu], [CmdBar], [Pages])
//
&НаКлиенте
Функция ОпределитьТегГруппы(ГруппаФормы)
	Попытка
		ВидГруппы = ГруппаФормы.Вид;
		
		// Маппинг видов групп на теги
		Если ВидГруппы = ВидГруппыФормы.КоманднаяПанель Тогда
			Возврат "CmdBar";
		ИначеЕсли ВидГруппы = ВидГруппыФормы.Подменю Тогда
			Возврат "Menu";
		ИначеЕсли ВидГруппы = ВидГруппыФормы.Страницы Тогда
			Возврат "Pages";
		ИначеЕсли ВидГруппы = ВидГруппыФормы.Страница Тогда
			Возврат "Tab";
		ИначеЕсли ВидГруппы = ВидГруппыФормы.ГруппаКнопок Тогда
			// Группа кнопок не всегда является меню, чаще это просто контейнер.
			// Оставляем как [Group] для универсальности. Специфику "меню" должен давать вид "Подменю".
			Возврат "Group";
		Иначе
			// Для всех остальных видов (Обычная, Подвал и т.д.)
			Возврат "Group";
		КонецЕсли;
		
	Исключение
		// При ошибке возвращаем Group по умолчанию
		Возврат "Group";
	КонецПопытки;
КонецФункции

// Определяет тег для декорации формы
//
// Параметры:
//   ДекорацияФормы - ДекорацияФормы - Декорация формы
//
// Возвращаемое значение:
//   Строка - Тег декорации ([Label], [Link], [Image])
//
&НаКлиенте
Функция ОпределитьТегДекорации(ДекорацияФормы)
	Попытка
		ВидДекорации = ДекорацияФормы.Вид;
		
		// Маппинг видов декораций на теги
		Если ВидДекорации = ВидДекорацииФормы.Надпись Тогда
			Возврат "Label";
		ИначеЕсли ВидДекорации = ВидДекорацииФормы.Картинка Тогда
			Возврат "Image";
		ИначеЕсли ВидДекорации = ВидДекорацииФормы.Гиперссылка Тогда
			Возврат "Link";
		Иначе
			// Для неизвестных видов возвращаем Label
			Возврат "Label";
		КонецЕсли;
		
	Исключение
		// При ошибке возвращаем Label по умолчанию
		Возврат "Label";
	КонецПопытки;
КонецФункции

// Проверяет, является ли элемент контейнером (имеет дочерние элементы)
//
// Параметры:
//   Элемент - ЭлементФормы - Элемент формы
//
// Возвращаемое значение:
//   Булево - Истина, если элемент является контейнером
//
&НаКлиенте
Функция ЭтоКонтейнер(Элемент)
	Попытка
		ТипЭлемента = ТипЗнч(Элемент);
		
		// Контейнерами являются группы и таблицы
		Если ТипЭлемента = Тип("ГруппаФормы") 
			Или ТипЭлемента = Тип("ТаблицаФормы") Тогда
			Возврат Истина;
		Иначе
			Возврат Ложь;
		КонецЕсли;
		
	Исключение
		Возврат Ложь;
	КонецПопытки;
КонецФункции

// Определяет заголовок элемента для AI (каскадный поиск)
//
// Параметры:
//   Элемент - ЭлементФормы - Элемент формы
//
// Возвращаемое значение:
//   Строка - Заголовок элемента для отображения в Markdown
//
&НаКлиенте
Функция ОпределитьЗаголовокДляAI(Элемент)
	// Каскад определения заголовка:
	// 1. Элемент.Заголовок
	// 2. Элемент.Подсказка
	// 3. Элемент.РасширеннаяПодсказка.Заголовок
	// 4. Элемент.Имя
	
	ИмяЭлементаДляЛога = ПолучитьСвойствоЭлемента(Элемент, "Имя");
	Лог(СтрШаблон("-> Определяем заголовок для '%1'", ИмяЭлементаДляЛога), "DEBUG");
	
	НайденныйЗаголовок = "";
	
	// Шаг 1: Попытка получить Заголовок
	Попытка
		НайденныйЗаголовок = СокрЛП(Строка(Элемент.Заголовок));
		Если Не ПустаяСтрока(НайденныйЗаголовок) Тогда
			Лог(СтрШаблон("   - [OK] Используем Элемент.Заголовок: ""%1""", НайденныйЗаголовок), "DEBUG");
			Возврат НайденныйЗаголовок;
		Иначе
			Лог("   - [Пропуск] Элемент.Заголовок пуст", "DEBUG");
		КонецЕсли;
	Исключение
		Лог("   - [Ошибка] Не удалось получить Элемент.Заголовок", "DEBUG");
	КонецПопытки;
	
	// Шаг 2: Попытка получить Подсказку
	Попытка
		НайденныйЗаголовок = СокрЛП(Строка(Элемент.Подсказка));
		Если Не ПустаяСтрока(НайденныйЗаголовок) Тогда
			Лог(СтрШаблон("   - [OK] Используем Элемент.Подсказка: ""%1""", НайденныйЗаголовок), "DEBUG");
			Возврат НайденныйЗаголовок;
		Иначе
			Лог("   - [Пропуск] Элемент.Подсказка пуст", "DEBUG");
		КонецЕсли;
	Исключение
		Лог("   - [Ошибка] Не удалось получить Элемент.Подсказка", "DEBUG");
	КонецПопытки;
	
	// Шаг 3: Попытка получить РасширеннаяПодсказка.Заголовок
	Попытка
		РасширеннаяПодсказка = Элемент.РасширеннаяПодсказка;
		Если РасширеннаяПодсказка <> Неопределено Тогда
			НайденныйЗаголовок = СокрЛП(Строка(РасширеннаяПодсказка.Заголовок));
			Если Не ПустаяСтрока(НайденныйЗаголовок) Тогда
				Лог(СтрШаблон("   - [OK] Используем РасширеннаяПодсказка.Заголовок: ""%1""", НайденныйЗаголовок), "DEBUG");
				Возврат НайденныйЗаголовок;
			Иначе
				Лог("   - [Пропуск] РасширеннаяПодсказка.Заголовок пуст", "DEBUG");
			КонецЕсли;
		Иначе
			Лог("   - [Пропуск] Элемент.РасширеннаяПодсказка не определена", "DEBUG");
		КонецЕсли;
	Исключение
		Лог("   - [Ошибка] Не удалось получить Элемент.РасширеннаяПодсказка", "DEBUG");
	КонецПопытки;
	
	// Шаг 4: Используем имя элемента
	Попытка
		НайденныйЗаголовок = СокрЛП(Строка(Элемент.Имя));
		Если Не ПустаяСтрока(НайденныйЗаголовок) Тогда
			Лог(СтрШаблон("   - [OK] Используем Элемент.Имя: ""%1""", НайденныйЗаголовок), "DEBUG");
			Возврат НайденныйЗаголовок;
		Иначе
			Лог("   - [Пропуск] Элемент.Имя пусто", "DEBUG");
		КонецЕсли;
	Исключение
		Лог("   - [Ошибка] Не удалось получить Элемент.Имя", "DEBUG");
	КонецПопытки;
	
	// Если все не удалось - возвращаем имя элемента как запасной вариант
	Лог("<- [Внимание] Не удалось найти заголовок для элемента. Возвращаем 'БезЗаголовка'.", "DEBUG");
	Возврат "БезЗаголовка";
КонецФункции

// Формирует строку опций элемента для Markdown v2.0
//
// Параметры:
//   Элемент - ЭлементФормы - Элемент формы
//   СкрытФлаг - Булево - Признак скрытого элемента
//
// Возвращаемое значение:
//   Строка - Строка опций (*Required *ReadOnly {Hidden}) или пустая строка
//
&НаКлиенте
Функция СформироватьОпции(Элемент, СкрытФлаг = Ложь)
	МассивОпций = Новый Массив;
	
	// Проверка обязательности заполнения
	Если ПроверитьТребуетсяОтметка(Элемент) Тогда
		МассивОпций.Добавить("*Required");
	КонецЕсли;
	
	// Проверка только для чтения
	Если ПроверитьТолькоЧтение(Элемент) Тогда
		МассивОпций.Добавить("*ReadOnly");
	КонецЕсли;
	
	// Добавление метки скрытого элемента
	Если СкрытФлаг Тогда
		МассивОпций.Добавить("{Hidden}");
	КонецЕсли;
	
	// Объединяем опции через пробел
	Если МассивОпций.Количество() > 0 Тогда
		Возврат СтрСоединить(МассивОпций, " ");
	Иначе
		Возврат "";
	КонецЕсли;
КонецФункции

// Проверяет, требуется ли отметка незаполненного для элемента
//
// Параметры:
//   Элемент - ЭлементФормы - Элемент формы
//
// Возвращаемое значение:
//   Булево - Истина, если АвтоОтметкаНезаполненного = Истина
//
&НаКлиенте
Функция ПроверитьТребуетсяОтметка(Элемент)
	Попытка
		// Проверяем свойство АвтоОтметкаНезаполненного
		Если Элемент.АвтоОтметкаНезаполненного = Истина Тогда
			Возврат Истина;
		КонецЕсли;
	Исключение
		// Свойство недоступно для данного типа элемента.
		// Ничего не делаем, возвращаем Ложь.
		ТекстОшибки = "";
	КонецПопытки;
	
	Возврат Ложь;
КонецФункции

// Проверяет, является ли элемент только для чтения
//
// Параметры:
//   Элемент - ЭлементФормы - Элемент формы
//
// Возвращаемое значение:
//   Булево - Истина, если элемент только для чтения
//
&НаКлиенте
Функция ПроверитьТолькоЧтение(Элемент)
	// Проверка 1: ТолькоПросмотр = Истина
	Попытка
		Если Элемент.ТолькоПросмотр = Истина Тогда
			Возврат Истина;
		КонецЕсли;
	Исключение
		// Свойство недоступно для данного типа элемента.
		// Ничего не делаем, возвращаем Ложь.
		ТекстОшибки = "";
	КонецПопытки;
	
	// Проверка 2: Доступность = Ложь
	Попытка
		Если Элемент.Доступность = Ложь Тогда
			Возврат Истина;
		КонецЕсли;
	Исключение
		// Свойство недоступно для данного типа элемента.
		// Ничего не делаем, возвращаем Ложь.
		ТекстОшибки = "";
	КонецПопытки;
	
	Возврат Ложь;
КонецФункции

#КонецОбласти

#Область ГенерацияMarkdownV2

// Создает строку отступов для иерархической структуры
//
// Параметры:
//   Глубина - Число - Уровень вложенности (0, 1, 2, ...)
//
// Возвращаемое значение:
//   Строка - Строка с отступами (2 пробела * Глубина)
//
&НаКлиенте
Функция СоздатьОтступ(Глубина)
	Если Глубина <= 0 Тогда
		Возврат "";
	КонецЕсли;
	
	Отступ = "";
	Для Индекс = 1 По Глубина Цикл
		Отступ = Отступ + "  "; // 2 пробела
	КонецЦикла;
	
	Возврат Отступ;
КонецФункции

// Генерирует Markdown в новом иерархическом формате v2.0
//
// Параметры:
//   Форма - УправляемаяФорма - Форма для генерации
//
// Возвращаемое значение:
//   Строка - Markdown текст в иерархическом формате
//
&НаКлиенте
Функция СгенерироватьMarkdownНовыйФормат(Форма)
	Результат = "";
	
	// Заголовок формы
	Результат = Результат + "# Form: " + ПолучитьЗаголовокФормы(Форма) + Символы.ПС;
	
	// Добавляем командную панель формы в первую очередь
	Попытка
		КП = Форма.Элементы.ФормаКоманднаяПанель;
		СтрокиКП = СформироватьСтрокиЭлементаРекурсивно(
			КП, 0, Объект.ВключатьНевидимыеЭлементы, Неопределено
		);
		Результат = Результат + СтрокиКП;
	Исключение
		// Командная панель может отсутствовать, это нормально.
		// Ничего не делаем.
		ТекстОшибки = "";
	КонецПопытки;
	
	// Рекурсивно обходим остальные элементы верхнего уровня
	КоллекцияКорневых = Форма.ПодчиненныеЭлементы;
	
	Для Каждого Элемент Из КоллекцияКорневых Цикл
		// Пропускаем командную панель, так как она уже обработана
		Если Элемент.Имя = "ФормаКоманднаяПанель" Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокиЭлемента = СформироватьСтрокиЭлементаРекурсивно(
			Элемент,
			0,
			Объект.ВключатьНевидимыеЭлементы,
			Неопределено
		);
		Результат = Результат + СтрокиЭлемента;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Формирует строки элемента и его детей рекурсивно для Markdown v2.0
//
// Параметры:
//   Элемент - ЭлементФормы - Элемент формы
//   Глубина - Число - Текущая глубина вложенности (для отступов)
//   ВыгружатьСкрытые - Булево - Выгружать ли скрытые элементы
//   РодительЭлемент - ЭлементФормы - Родительский элемент (для определения контекста)
//
// Возвращаемое значение:
//   Строка - Markdown строки для элемента и его детей
//
&НаКлиенте
Функция СформироватьСтрокиЭлементаРекурсивно(Элемент, Глубина, ВыгружатьСкрытые, РодительЭлемент)
	
	// Инициализация флагов
	СкрытФлаг = Ложь;
	ПропускатьДетей = Ложь;
	
	// 1. ПРОВЕРКА ВИДИМОСТИ
	Попытка
		Видимость = Элемент.Видимость;
		
		Если Не Видимость Тогда
			Если Не ВыгружатьСкрытые Тогда
				Возврат ""; // Пропускаем полностью
			КонецЕсли;
			
			СкрытФлаг = Истина;
			
			// Если это контейнер (Group, Table, Tab) - не обходим детей
			Если ЭтоКонтейнер(Элемент) Тогда
				ПропускатьДетей = Истина;
			КонецЕсли;
		КонецЕсли;
	Исключение
		// Свойство Видимость недоступно - считаем элемент видимым.
		// Ничего не делаем.
		ТекстОшибки = "";
	КонецПопытки;
	
	// 2. ФОРМИРОВАНИЕ СТРОКИ
	Отступ = СоздатьОтступ(Глубина);
	Тег = ОпределитьТегЭлемента(Элемент, РодительЭлемент);
	
	Если Тег = "skip" Тогда
		Возврат ""; // Служебный элемент
	КонецЕсли;
	
	НайденныйЗаголовок = ОпределитьЗаголовокДляAI(Элемент);
	ИмяЭлемента = ПолучитьСвойствоЭлемента(Элемент, "Имя");
	Опции = СформироватьОпции(Элемент, СкрытФлаг);
	
	// Формат: - [Tag] "Title" (Name) {Options}
	Результат = СтрШаблон("%1- [%2] ""%3"" (%4)%5",
		Отступ, Тег, НайденныйЗаголовок, ИмяЭлемента,
		?(ПустаяСтрока(Опции), "", " " + Опции)
	) + Символы.ПС;
	
	// 3. РЕКУРСИЯ (если не пропускаем детей)
	ТекстДочернихЭлементов = "";
	Если Не ПропускатьДетей Тогда
		Попытка
			КоллекцияПодчиненных = Элемент.ПодчиненныеЭлементы;
			
			Для Каждого ДочернийЭлемент Из КоллекцияПодчиненных Цикл
				ТекстДочернихЭлементов = ТекстДочернихЭлементов + СформироватьСтрокиЭлементаРекурсивно(
					ДочернийЭлемент,
					Глубина + 1,
					ВыгружатьСкрытые,
					Элемент  // Передаем текущий элемент как родителя
				);
			КонецЦикла;
		Исключение
			// У элемента нет подчиненных элементов, это нормально.
			// Ничего не делаем.
			ТекстОшибки = "";
		КонецПопытки;
	КонецЕсли;
	
	// 4. ПРОВЕРКА НА ПУСТУЮ ГРУППУ
	// Если элемент является контейнером, но не имеет дочерних элементов (и видимых кнопок),
	// то не выводим его.
	Если ЭтоКонтейнер(Элемент) И ПустаяСтрока(ТекстДочернихЭлементов) Тогда
		Возврат "";
	КонецЕсли;
	
	// Собираем итоговый результат
	Результат = Результат + ТекстДочернихЭлементов;
	
	Возврат Результат;
КонецФункции

#КонецОбласти

#КонецОбласти

#Область ГенерацияВыходныхФайлов

// Генерирует Markdown документацию по форме
//
// Параметры:
//   ДанныеФормы - Структура - Данные формы
//
// Возвращаемое значение:
//   Строка - Markdown текст
//
&НаСервере
Функция СгенерироватьMarkdown(ДанныеФормы)
	Результат = "";
	
	// Заголовок
	Результат = Результат + "# Форма: " + ДанныеФормы.title + Символы.ПС + Символы.ПС;
	Результат = Результат + "**Полное имя:** `" + ДанныеФормы.form_name + "`" + Символы.ПС;
	Результат = Результат + "**Тип:** " + ДанныеФормы.form_type + Символы.ПС;
	Результат = Результат + "**Собрано:** " + Формат(ДанныеФормы.metadata.collected_at, "ДФ='dd.MM.yyyy HH:mm'") + Символы.ПС + Символы.ПС;
	Результат = Результат + "---" + Символы.ПС + Символы.ПС;
	
	// Группировка элементов по типам (рекурсивно обходим всё дерево)
	ПоляВвода = Новый Массив;
	Кнопки = Новый Массив;
	Таблицы = Новый Массив;
	Группы = Новый Массив;
	
	// Рекурсивная функция для сбора всех элементов
	СобратьЭлементыДляMarkdown(ДанныеФормы.elements, ПоляВвода, Кнопки, Таблицы, Группы);
	
	// Поля ввода
	Если ПоляВвода.Количество() > 0 Тогда
		Результат = Результат + "## 📝 Поля формы" + Символы.ПС + Символы.ПС;
		Для Каждого Поле Из ПоляВвода Цикл
			Результат = Результат + "- `" + Поле.name + "`";
			
			// Безопасно проверяем наличие title
			Если Поле.Свойство("title") И Не ПустаяСтрока(Поле.title) Тогда
				Результат = Результат + " - " + Поле.title;
			КонецЕсли;
			
			// Добавляем вид поля
			Если Поле.Свойство("kind") И Не ПустаяСтрока(Поле.kind) Тогда
				Результат = Результат + " [" + Поле.kind + "]";
			КонецЕсли;
			
			Результат = Результат + Символы.ПС;
		КонецЦикла;
		Результат = Результат + Символы.ПС;
	КонецЕсли;
	
	// Таблицы
	Если Таблицы.Количество() > 0 Тогда
		Результат = Результат + "## 📊 Табличные части" + Символы.ПС + Символы.ПС;
		Для Каждого Таблица Из Таблицы Цикл
			Результат = Результат + "### " + Таблица.name;
			
			// Безопасно проверяем наличие title
			Если Таблица.Свойство("title") И Не ПустаяСтрока(Таблица.title) Тогда
				Результат = Результат + " - " + Таблица.title;
			КонецЕсли;
			
			Результат = Результат + Символы.ПС + Символы.ПС;
		КонецЦикла;
	КонецЕсли;
	
	// Кнопки
	Если Кнопки.Количество() > 0 Тогда
		Результат = Результат + "## 🔘 Команды" + Символы.ПС + Символы.ПС;
		Для Каждого Кнопка Из Кнопки Цикл
			Результат = Результат + "- `" + Кнопка.name + "`";
			
			// Безопасно проверяем наличие title
			Если Кнопка.Свойство("title") И Не ПустаяСтрока(Кнопка.title) Тогда
				Результат = Результат + " - " + Кнопка.title;
			КонецЕсли;
			
			Результат = Результат + Символы.ПС;
		КонецЦикла;
		Результат = Результат + Символы.ПС;
	КонецЕсли;
	
	// Статистика
	Результат = Результат + "---" + Символы.ПС + Символы.ПС;
	Результат = Результат + "**Всего элементов:** " + Формат(ДанныеФормы.elements.Количество(), "ЧГ=") + Символы.ПС;
	
	Возврат Результат;
КонецФункции

// Рекурсивно собирает элементы всех типов из дерева
//
// Параметры:
//   МассивЭлементов - Массив - Массив элементов для обхода
//   ПоляВвода - Массив - Массив для сбора полей
//   Кнопки - Массив - Массив для сбора кнопок
//   Таблицы - Массив - Массив для сбора таблиц
//   Группы - Массив - Массив для сбора групп
//
&НаСервере
Процедура СобратьЭлементыДляMarkdown(МассивЭлементов, ПоляВвода, Кнопки, Таблицы, Группы)
	Для Каждого Элемент Из МассивЭлементов Цикл
		Если Элемент.type = "field" Тогда
			ПоляВвода.Добавить(Элемент);
		ИначеЕсли Элемент.type = "button" Тогда
			Кнопки.Добавить(Элемент);
		ИначеЕсли Элемент.type = "table" Тогда
			Таблицы.Добавить(Элемент);
		ИначеЕсли Элемент.type = "group" Тогда
			Группы.Добавить(Элемент);
		КонецЕсли;
		
		// Рекурсивно обрабатываем дочерние элементы
		Если Элемент.Свойство("children") Тогда
			СобратьЭлементыДляMarkdown(Элемент.children, ПоляВвода, Кнопки, Таблицы, Группы);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Формирует имя файла на основе полного имени формы
//
// Параметры:
//   ПолноеИмяФормы - Строка - Полное имя формы
//
// Возвращаемое значение:
//   Строка - Имя файла без расширения
//
&НаСервере
Функция СформироватьИмяФайла(ПолноеИмяФормы)
	// Заменяем разделители на точки
	ИмяФайла = СтрЗаменить(ПолноеИмяФормы, "/", ".");
	ИмяФайла = СтрЗаменить(ИмяФайла, "\", ".");
	
	Возврат ИмяФайла;
КонецФункции

#КонецОбласти

#Область РаботаСФайлами

// Получает путь к каталогу для сохранения контекста
//
// Возвращаемое значение:
//   Строка - Путь к каталогу context/forms/
//
&НаСервере
Функция ПолучитьПутьКонтекста()
	// Получаем путь к файлу обработки через экспортную функцию объекта
	ПутьКОбработке = РеквизитФормыВЗначение("Объект").ПолучитьПутьКФайлуОбработки();
	
	// Извлекаем директорию обработки
	ФайлОбработки = Новый Файл(ПутьКОбработке);
	КаталогОбработки = ФайлОбработки.Путь;
	
	// Поднимаемся на 1 уровень вверх: tools/form-context/ -> tools/
	ФайлКаталогаОбработки = Новый Файл(КаталогОбработки);
	КаталогTools = ФайлКаталогаОбработки.Путь;
	
	// Поднимаемся еще на 1 уровень вверх: tools/ -> корень проекта
	ФайлКаталогаTools = Новый Файл(КаталогTools);
	КорневойКаталог = ФайлКаталогаTools.Путь;
	
	// Формируем путь к context/forms/
	ПутьКонтекста = КорневойКаталог + "context" + ПолучитьРазделительПути() + "forms" + ПолучитьРазделительПути();
	
	// Создаем директорию если не существует
	ФайлКаталога = Новый Файл(ПутьКонтекста);
	Если Не ФайлКаталога.Существует() Тогда
		СоздатьКаталог(ПутьКонтекста);
	КонецЕсли;
	
	Возврат ПутьКонтекста;
КонецФункции

// Преобразует структуру данных в JSON
//
// Параметры:
//   Данные - Структура - Данные для преобразования
//
// Возвращаемое значение:
//   Строка - JSON строка
//
&НаКлиенте
Функция ПреобразоватьВJSON(Данные)
	Возврат ПреобразоватьВJSONНаСервере(Данные);
КонецФункции

// Преобразует структуру данных в JSON (серверная часть)
//
// Параметры:
//   Данные - Структура - Данные для преобразования
//
// Возвращаемое значение:
//   Строка - JSON строка
//
&НаСервере
Функция ПреобразоватьВJSONНаСервере(Данные)
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку(Новый ПараметрыЗаписиJSON(, Символы.Таб));
	ЗаписатьJSON(ЗаписьJSON, Данные);
	
	Возврат ЗаписьJSON.Закрыть();
КонецФункции

// Сохраняет текст в файл
//
// Параметры:
//   Текст - Строка - Текст для сохранения
//   ПутьКФайлу - Строка - Полный путь к файлу
//
&НаКлиенте
Процедура СохранитьВФайл(Текст, ПутьКФайлу)
	СохранитьВФайлНаСервере(Текст, ПутьКФайлу);
КонецПроцедуры

// Сохраняет текст в файл (серверная часть)
//
// Параметры:
//   Текст - Строка - Текст для сохранения
//   ПутьКФайлу - Строка - Полный путь к файлу
//
&НаСервере
Процедура СохранитьВФайлНаСервере(Текст, ПутьКФайлу)
	ЗаписьТекста = Новый ЗаписьТекста(ПутьКФайлу, КодировкаТекста.UTF8);
	ЗаписьТекста.Записать(Текст);
	ЗаписьТекста.Закрыть();
КонецПроцедуры

// Обновляет индексный файл со списком всех форм
//
// Параметры:
//   ДанныеФормы - Структура - Данные формы
//   ИмяФайлаJSON - Строка - Имя JSON файла
//
&НаСервере
Процедура ОбновитьИндексФорм(ДанныеФормы, ИмяФайлаJSON)
	ПутьИндекса = Объект.ПутьСохранения + "index.json";
	
	// Читаем существующий индекс
	ФайлИндекса = Новый Файл(ПутьИндекса);
	
	Если ФайлИндекса.Существует() Тогда
		ЧтениеТекста = Новый ЧтениеТекста(ПутьИндекса, КодировкаТекста.UTF8);
		ТекстJSON = ЧтениеТекста.Прочитать();
		ЧтениеТекста.Закрыть();
		
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ТекстJSON);
		Индекс = ПрочитатьJSON(ЧтениеJSON);
		ЧтениеJSON.Закрыть();
	Иначе
		Индекс = Новый Структура;
		Индекс.Вставить("version", "1.0");
		Индекс.Вставить("forms", Новый Структура);
	КонецЕсли;
	
	// Обновляем/добавляем запись о форме
	ЗаписьФормы = Новый Структура;
	ЗаписьФормы.Вставить("title", ДанныеФормы.title);
	ЗаписьФормы.Вставить("type", ДанныеФормы.form_type);
	ЗаписьФормы.Вставить("json_path", ИмяФайлаJSON);
	
	Если Объект.ГенерироватьMarkdown Тогда
		ИмяФайлаMD = СтрЗаменить(ИмяФайлаJSON, ".json", ".md");
		ЗаписьФормы.Вставить("markdown_path", ИмяФайлаMD);
	КонецЕсли;
	
	ЗаписьФормы.Вставить("collected_at", ДанныеФормы.metadata.collected_at);
	ЗаписьФормы.Вставить("element_count", ДанныеФормы.elements.Количество());
	ЗаписьФормы.Вставить("detail_level", ДанныеФормы.metadata.detail_level);
	
	// Используем безопасное имя ключа (заменяем точки на подчеркивания)
	БезопасноеИмяКлюча = СтрЗаменить(ДанныеФормы.form_name, ".", "_");
	Индекс.forms.Вставить(БезопасноеИмяКлюча, ЗаписьФормы);
	Индекс.Вставить("updated_at", ТекущаяДатаСеанса());
	
	// Сохраняем индекс
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку(Новый ПараметрыЗаписиJSON(, Символы.Таб));
	ЗаписатьJSON(ЗаписьJSON, Индекс);
	ТекстИндекса = ЗаписьJSON.Закрыть();
	
	ЗаписьТекста = Новый ЗаписьТекста(ПутьИндекса, КодировкаТекста.UTF8);
	ЗаписьТекста.Записать(ТекстИндекса);
	ЗаписьТекста.Закрыть();
КонецПроцедуры

#КонецОбласти

#Область АгентскийРежим

// Проверяет режим запуска обработки
//
// Возвращаемое значение:
//   Строка - "agent" или "interactive"
//
&НаКлиенте
Функция ПроверитьРежимЗапуска()
	Попытка
		ПутьКTaskJSON = ПолучитьПутьКTaskJSONНаСервере();
		ФайлTask = Новый Файл(ПутьКTaskJSON);
		
		Если ФайлTask.Существует() Тогда
			Возврат "agent";
		Иначе
			Возврат "interactive";
		КонецЕсли;
	Исключение
		Возврат "interactive";
	КонецПопытки;
КонецФункции

// Получает путь к файлу task.json
//
// Возвращаемое значение:
//   Строка - Путь к task.json
//
&НаСервере
Функция ПолучитьПутьКTaskJSONНаСервере()
	// Получаем путь к файлу обработки через экспортную функцию объекта
	ПутьКОбработке = РеквизитФормыВЗначение("Объект").ПолучитьПутьКФайлуОбработки();
	ФайлОбработки = Новый Файл(ПутьКОбработке);
	КаталогОбработки = ФайлОбработки.Путь;
	
	ПутьКTaskJSON = КаталогОбработки + "agent" + ПолучитьРазделительПути() + "task.json";
	
	Возврат ПутьКTaskJSON;
КонецФункции

// Читает и парсит файл task.json.processing
//
// Возвращаемое значение:
//   Структура - Задание агента с полями:
//     * version - Строка - Версия формата
//     * mode - Строка - Режим (agent)
//     * forms - Массив - Список форм для обработки
//     * options - Структура - Настройки обработки
//
&НаСервере
Функция ПрочитатьTaskJSON()
	ПутьКTaskJSON = ПолучитьПутьКTaskJSONНаСервере();
	
	// Читаем файл .processing (он уже должен быть переименован)
	ПутьProcessing = ПутьКTaskJSON + ".processing";
	ФайлProcessing = Новый Файл(ПутьProcessing);
	
	Если Не ФайлProcessing.Существует() Тогда
		ВызватьИсключение "Файл task.json.processing не найден по пути: " + ПутьProcessing;
	КонецЕсли;
	
	// Читаем содержимое
	ЧтениеТекста = Новый ЧтениеТекста(ПутьProcessing, КодировкаТекста.UTF8);
	ТекстJSON = ЧтениеТекста.Прочитать();
	ЧтениеТекста.Закрыть();
	
	// Парсим JSON
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(ТекстJSON);
	Задание = ПрочитатьJSON(ЧтениеJSON);
	ЧтениеJSON.Закрыть();
	
	// Проверяем обязательные поля
	Если Не Задание.Свойство("forms") Тогда
		ВызватьИсключение "В task.json отсутствует обязательное поле 'forms'";
	КонецЕсли;
	
	// Устанавливаем значения по умолчанию для options
	Если Не Задание.Свойство("options") Тогда
		Задание.Вставить("options", Новый Структура);
	КонецЕсли;
	
	Опции = Задание.options;
	
	Если Не Опции.Свойство("include_invisible") Тогда
		Опции.Вставить("include_invisible", Ложь);
	КонецЕсли;
	
	Если Не Опции.Свойство("generate_markdown") Тогда
		Опции.Вставить("generate_markdown", Истина);
	КонецЕсли;
	
	Если Не Опции.Свойство("max_depth") Тогда
		Опции.Вставить("max_depth", 5);
	КонецЕсли;
	
	Если Не Опции.Свойство("close_after_collection") Тогда
		Опции.Вставить("close_after_collection", Истина);
	КонецЕсли;
	
	Если Не Опции.Свойство("wait_form_timeout") Тогда
		Опции.Вставить("wait_form_timeout", 2000);
	КонецЕсли;
	
	Возврат Задание;
КонецФункции

// Получает задание агента на клиенте
//
// Возвращаемое значение:
//   Структура - Задание агента
//
&НаКлиенте
Функция ПолучитьЗаданиеАгента()
	Возврат ПрочитатьTaskJSON();
КонецФункции

// Переименовывает файл task.json для отслеживания статуса
//
// Параметры:
//   НовыйСтатус - Строка - Статус: "processing", "completed", "error"
//
&НаСервере
Процедура ПереименоватьTaskJSON(НовыйСтатус)
	ПутьБазовый = ПолучитьПутьКTaskJSONНаСервере();
	
	Если НовыйСтатус = "processing" Тогда
		// task.json → task.json.processing
		ИсходныйФайл = ПутьБазовый;
		НовыйФайл = ПутьБазовый + ".processing";
		
		ФайлИсходный = Новый Файл(ИсходныйФайл);
		Если Не ФайлИсходный.Существует() Тогда
			ВызватьИсключение "Файл task.json не найден для переименования";
		КонецЕсли;
		
	Иначе
		// task.json.processing → task.json.completed/error
		ИсходныйФайл = ПутьБазовый + ".processing";
		НовыйФайл = ПутьБазовый + "." + НовыйСтатус;
		
		ФайлИсходный = Новый Файл(ИсходныйФайл);
		Если Не ФайлИсходный.Существует() Тогда
			ВызватьИсключение "Файл task.json.processing не найден для переименования";
		КонецЕсли;
		
		// Удаляем старый файл со статусом если есть
		ФайлУдаляемый = Новый Файл(НовыйФайл);
		Если ФайлУдаляемый.Существует() Тогда
			УдалитьФайлы(НовыйФайл);
		КонецЕсли;
	КонецЕсли;
	
	// Переименовываем файл
	ПереместитьФайл(ИсходныйФайл, НовыйФайл);
КонецПроцедуры

// Обновляет статус файла task.json на клиенте
//
// Параметры:
//   Статус - Строка - Новый статус файла
//
&НаКлиенте
Процедура ОбновитьСтатусTaskJSON(Статус)
	ПереименоватьTaskJSONНаСервере(Статус);
КонецПроцедуры

// Обертка для вызова серверной процедуры переименования
//
// Параметры:
//   Статус - Строка - Новый статус файла
//
&НаСервере
Процедура ПереименоватьTaskJSONНаСервере(Статус)
	ПереименоватьTaskJSON(Статус);
КонецПроцедуры

// Выполняет агентский режим (автоматический сбор)
//
&НаКлиенте
Процедура ВыполнитьАгентскийРежим()
	Лог("=== АГЕНТСКИЙ РЕЖИМ: Запуск ===");
	
	Попытка
		// 1. Переименовываем файл task.json → task.json.processing
		Лог("Переименование task.json → task.json.processing");
		ОбновитьСтатусTaskJSON("processing");
		
		// 2. Читаем задание
		Лог("Чтение задания из task.json.processing");
		Задание = ПолучитьЗаданиеАгента();
		
		Лог(СтрШаблон("Загружено задание версии %1", Задание.version));
		Лог(СтрШаблон("Форм для обработки: %1", Задание.forms.Количество()));
		
		// 3. Применяем настройки из задания
		ПрименитьНастройкиЗадания(Задание.options);
		
		// 4. Инициализируем массив для обработки
		МассивФормДляОбработки = Задание.forms;
		
		// Проверяем, есть ли формы для обработки
		Если МассивФормДляОбработки.Количество() = 0 Тогда
			Лог("ПРЕДУПРЕЖДЕНИЕ: Список форм пуст", "ERROR");
			ОбновитьСтатусTaskJSON("completed");
			СтатусСбора = "Агентский режим: список форм пуст";
			Возврат;
		КонецЕсли;
		
		// 5. Запускаем обработку первой формы
		СтатусСбора = СтрШаблон("Обработка 0 из %1 форм...", МассивФормДляОбработки.Количество());
		ИндексТекущейФормы = 0;
		ОбработатьСледующуюФормуАгента(МассивФормДляОбработки, ИндексТекущейФормы, Задание);
		
	Исключение
		ТекстОшибки = ОписаниеОшибки();
		Лог("КРИТИЧЕСКАЯ ОШИБКА в агентском режиме: " + ТекстОшибки, "ERROR");
		Лог("Подробно: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), "ERROR");
		
		// Помечаем как ошибку
		Попытка
			ОбновитьСтатусTaskJSON("error");
		Исключение
			Лог("Не удалось переименовать task.json в .error: " + ОписаниеОшибки(), "ERROR");
		КонецПопытки;
		
		СтатусСбора = "Ошибка агентского режима: " + ТекстОшибки;
	КонецПопытки;
КонецПроцедуры

// Обрабатывает следующую форму в очереди агентского режима
//
// Параметры:
//   МассивФорм - Массив из Структура - Список форм для обработки
//   Индекс - Число - Индекс текущей формы (0-based)
//   Задание - Структура - Полное задание агента
//
&НаКлиенте
Процедура ОбработатьСледующуюФормуАгента(МассивФорм, Индекс, Задание)
	// Проверяем, есть ли еще формы для обработки
	Если Индекс >= МассивФорм.Количество() Тогда
		// Все формы обработаны
		Лог("Все формы обработаны");
		ЗавершитьАгентскийРежим(Задание, "completed");
		Возврат;
	КонецЕсли;
	
	ОписаниеФормы = МассивФорм[Индекс];
	Лог("");
	Лог(СтрШаблон("=== Обработка формы %1 из %2 ===",
		Индекс + 1, МассивФорм.Количество()));
	Лог(СтрШаблон("Форма: %1 (тип: %2)", ОписаниеФормы.value, ОписаниеФормы.type));
	
	СтатусСбора = СтрШаблон("Обработка %1 из %2 форм...",
		Индекс + 1, МассивФорм.Количество());
	
	// Создаем оповещение для обработки результата открытия
	Оповещение = Новый ОписаниеОповещения(
		"ПослеОткрытияФормыАгента",
		ЭтотОбъект,
		Новый Структура("МассивФорм, Индекс, Задание, ОписаниеФормы",
			МассивФорм, Индекс, Задание, ОписаниеФормы)
	);
	
	// Открываем форму программно
	ОткрытьФормуПрограммно(ОписаниеФормы, Оповещение);
КонецПроцедуры

// Обработчик после открытия формы в агентском режиме
//
// Параметры:
//   УИДФормы - Строка, Неопределено - УИД открытой формы или Неопределено при ошибке
//   ДополнительныеПараметры - Структура - Контекст обработки
//
&НаКлиенте
Процедура ПослеОткрытияФормыАгента(УИДФормы, ДополнительныеПараметры) Экспорт
	МассивФорм = ДополнительныеПараметры.МассивФорм;
	Индекс = ДополнительныеПараметры.Индекс;
	Задание = ДополнительныеПараметры.Задание;
	ОписаниеФормы = ДополнительныеПараметры.ОписаниеФормы;
	
	Если УИДФормы = Неопределено Тогда
		// Форма не открылась - логируем ошибку и переходим к следующей
		Лог(СтрШаблон("✗ Форма %1 не открылась, пропускаем",
			ОписаниеФормы.value), "ERROR");
		
		// Переходим к следующей форме
		ОбработатьСледующуюФормуАгента(МассивФорм, Индекс + 1, Задание);
		Возврат;
	КонецЕсли;
	
	// Ждем, пока форма полностью отобразится
	ТаймаутОжидания = Задание.options.wait_form_timeout;
	Лог(СтрШаблон("Ожидание отрисовки формы (%1 мс)...", ТаймаутОжидания));
	
	// Сохраняем параметры для обработчика ожидания
	ПараметрыОжидания = Новый Структура;
	ПараметрыОжидания.Вставить("УИДФормы", УИДФормы);
	ПараметрыОжидания.Вставить("МассивФорм", МассивФорм);
	ПараметрыОжидания.Вставить("Индекс", Индекс);
	ПараметрыОжидания.Вставить("Задание", Задание);
	ПараметрыОжидания.Вставить("ОписаниеФормы", ОписаниеФормы);
	
	// Сохраняем в реквизит формы для доступа из обработчика
	ПараметрыОбработкиФормыАгента = ПараметрыОжидания;
	
	// Подключаем обработчик ожидания (таймаут в секундах)
	ПодключитьОбработчикОжидания(
		"СобратьКонтекстОткрытойФормыАгента",
		ТаймаутОжидания / 1000.0,
		Истина
	);
КонецПроцедуры

// Собирает контекст открытой формы после ожидания
//
&НаКлиенте
Процедура СобратьКонтекстОткрытойФормыАгента()
	КонтекстВызова = ПараметрыОбработкиФормыАгента;
	УИДФормы = КонтекстВызова.УИДФормы;
	МассивФорм = КонтекстВызова.МассивФорм;
	Индекс = КонтекстВызова.Индекс;
	Задание = КонтекстВызова.Задание;
	ОписаниеФормы = КонтекстВызова.ОписаниеФормы;
	
	Попытка
		Лог("Поиск формы по УИД и сбор контекста...");
		
		// Ищем форму по УИД среди открытых форм
		СсылкаНаФорму = НайтиФормуПоУИД(УИДФормы);
		
		Если СсылкаНаФорму = Неопределено Тогда
			ВызватьИсключение "Форма не найдена по УИД " + УИДФормы;
		КонецЕсли;
		
		// Собираем контекст формы (переиспользуем существующий код!)
		Лог("Сбор информации о форме...");
		ДанныеФормы = СобратьИнформациюОФорме(СсылкаНаФорму);
		Лог(СтрШаблон("Собрано элементов: %1", ДанныеФормы.elements.Количество()));
		
		// Генерируем и сохраняем JSON
		Лог("Генерация JSON...");
		ТекстJSON = ПреобразоватьВJSON(ДанныеФормы);
		ИмяФайлаJSON = СформироватьИмяФайла(ДанныеФормы.form_name) + ".json";
		ПутьJSON = Объект.ПутьСохранения + ИмяФайлаJSON;
		СохранитьВФайл(ТекстJSON, ПутьJSON);
		Лог(СтрШаблон("Сохранен: %1", ПутьJSON));
		
		// Генерируем и сохраняем Markdown
		Если Объект.ГенерироватьMarkdown Тогда
			Лог("Генерация Markdown v2.0...");
			ТекстMarkdown = СгенерироватьMarkdownНовыйФормат(СсылкаНаФорму);
			ИмяФайлаMD = СформироватьИмяФайла(ДанныеФормы.form_name) + ".md";
			ПутьMD = Объект.ПутьСохранения + ИмяФайлаMD;
			СохранитьВФайл(ТекстMarkdown, ПутьMD);
			Лог(СтрШаблон("Сохранен: %1", ПутьMD));
		КонецЕсли;
		
		// Обновляем индекс форм
		Лог("Обновление index.json...");
		ОбновитьИндексФорм(ДанныеФормы, ИмяФайлаJSON);
		
		Лог(СтрШаблон("✓ Форма %1 обработана успешно", ДанныеФормы.form_name));
		
		// Закрываем форму
		Попытка
			СсылкаНаФорму.Закрыть();
			Лог("Форма закрыта");
		Исключение
			Лог("Предупреждение: не удалось закрыть форму - " + ОписаниеОшибки(), "DEBUG");
		КонецПопытки;
		
	Исключение
		ТекстОшибки = ОписаниеОшибки();
		Лог(СтрШаблон("✗ ОШИБКА при сборе контекста: %1", ТекстОшибки), "ERROR");
		Лог("Подробно: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), "ERROR");
	КонецПопытки;
	
	// Переходим к следующей форме (независимо от результата текущей)
	ОбработатьСледующуюФормуАгента(МассивФорм, Индекс + 1, Задание);
КонецПроцедуры

// Завершает агентский режим
//
// Параметры:
//   Задание - Структура - Задание агента
//   Статус - Строка - Итоговый статус: "completed" или "error"
//
&НаКлиенте
Процедура ЗавершитьАгентскийРежим(Задание, Статус)
	Лог("");
	Лог("=== АГЕНТСКИЙ РЕЖИМ: Завершение ===");
	Лог(СтрШаблон("Статус: %1", Статус));
	
	// Переименовываем файл в .completed или .error
	Попытка
		ОбновитьСтатусTaskJSON(Статус);
		Лог(СтрШаблон("Файл переименован в task.json.%1", Статус));
	Исключение
		Лог("ОШИБКА переименования task.json: " + ОписаниеОшибки(), "ERROR");
	КонецПопытки;
	
	// Проверяем, нужно ли закрывать 1С
	ЗакрыватьПослеЗавершения = Задание.options.close_after_collection;
	
	Если ЗакрыватьПослеЗавершения Тогда
		Лог("Закрытие 1С через 2 секунды...");
		СтатусСбора = "Агентский режим завершен. Закрытие 1С...";
		
		// Небольшая задержка чтобы лог успел записаться
		ПодключитьОбработчикОжидания("ЗакрытьПриложение", 2, Истина);
	Иначе
		Лог("1С остается открытым (close_after_collection = false)");
		СтатусСбора = "Агентский режим завершен. Результаты в context/forms/";
	КонецЕсли;
	
	Лог("=== Завершено ===");
КонецПроцедуры

// Закрывает приложение 1С
//
&НаКлиенте
Процедура ЗакрытьПриложение()
	Лог("Выполняется закрытие 1С...");
	ЗавершитьРаботуСистемы(Ложь);
КонецПроцедуры

// Применяет настройки из задания к обработке
//
// Параметры:
//   Опции - Структура - Настройки из задания
//
&НаКлиенте
Процедура ПрименитьНастройкиЗадания(Опции)
	Лог("Применение настроек задания:");
	
	Если Опции.Свойство("include_invisible") Тогда
		Объект.ВключатьНевидимыеЭлементы = Опции.include_invisible;
		Лог(СтрШаблон("  - Включать невидимые элементы: %1", Опции.include_invisible));
	КонецЕсли;
	
	Если Опции.Свойство("generate_markdown") Тогда
		Объект.ГенерироватьMarkdown = Опции.generate_markdown;
		Лог(СтрШаблон("  - Генерировать Markdown: %1", Опции.generate_markdown));
	КонецЕсли;
	
	Если Опции.Свойство("max_depth") Тогда
		Объект.МаксимальнаяГлубинаВложенности = Опции.max_depth;
		Лог(СтрШаблон("  - Максимальная глубина: %1", Опции.max_depth));
	КонецЕсли;
	
	Лог("Настройки применены");
КонецПроцедуры

// Программно открывает указанную форму
//
// Параметры:
//   ОписаниеФормы - Структура - Описание формы с полями:
//     * type - Строка - Тип: "form_path" или "metadata_object"
//     * value - Строка - Значение (путь или имя объекта)
//     * form_name - Строка - Имя формы (для metadata_object)
//   ОповещениеОЗавершении - ОписаниеОповещения - Оповещение с результатом
//
&НаКлиенте
Процедура ОткрытьФормуПрограммно(ОписаниеФормы, ОповещениеОЗавершении)
	Лог(СтрШаблон("Программное открытие формы: %1 (тип: %2)",
		ОписаниеФормы.value, ОписаниеФормы.type));
	
	ПараметрыФормы = Новый Структура;
	ПутьКФорме = "";
	
	// Определяем путь к форме в зависимости от типа
	Если ОписаниеФормы.type = "form_path" Тогда
		// Полный путь: Документ.ЗаказПокупателя.Форма.ФормаДокумента
		ПутьКФорме = ОписаниеФормы.value;
		Лог(СтрШаблон("  Полный путь: %1", ПутьКФорме));
		
	ИначеЕсли ОписаниеФормы.type = "metadata_object" Тогда
		// Объект + имя формы: Справочник.Контрагенты + ФормаЭлемента
		ИмяФормы = ?(ОписаниеФормы.Свойство("form_name"),
			ОписаниеФормы.form_name, "ФормаОбъекта");
		ПутьКФорме = ОписаниеФормы.value + ".Форма." + ИмяФормы;
		Лог(СтрШаблон("  Объект: %1, Форма: %2 → %3",
			ОписаниеФормы.value, ИмяФормы, ПутьКФорме));
		
	Иначе
		ТекстОшибки = "Неизвестный тип формы: " + ОписаниеФормы.type;
		Лог("ОШИБКА: " + ТекстОшибки, "ERROR");
		ВыполнитьОбработкуОповещения(ОповещениеОЗавершении, Неопределено);
		Возврат;
	КонецЕсли;
	
	// Пытаемся открыть форму
	Попытка
		// Открываем форму
		ОткрытаяФорма = ОткрытьФорму(ПутьКФорме, ПараметрыФормы);
		
		// Сохраняем УИД для последующего поиска
		УИДОткрытойФормы = Строка(ОткрытаяФорма.УникальныйИдентификатор);
		
		Лог(СтрШаблон("  ✓ Форма открыта успешно. УИД: %1", УИДОткрытойФормы));
		
		// Возвращаем УИД через оповещение
		ВыполнитьОбработкуОповещения(ОповещениеОЗавершении, УИДОткрытойФормы);
		
	Исключение
		ТекстОшибки = ОписаниеОшибки();
		Лог("ОШИБКА при открытии формы: " + ТекстОшибки, "ERROR");
		Лог("Подробно: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), "ERROR");
		
		// Возвращаем Неопределено в случае ошибки
		ВыполнитьОбработкуОповещения(ОповещениеОЗавершении, Неопределено);
	КонецПопытки;
КонецПроцедуры

#КонецОбласти

#Область СистемаЛогирования

// Записывает сообщение в лог отладки
//
// Параметры:
//   Сообщение - Строка - Текст сообщения
//   Уровень - Строка - Уровень сообщения (INFO, ERROR, DEBUG)
//
&НаКлиенте
Процедура Лог(Сообщение, Уровень = "INFO")
	Если Не Объект.РежимОтладки Тогда
		Возврат;
	КонецЕсли;
	
	ЛогНаСервере(Сообщение, Уровень);
КонецПроцедуры

// Записывает сообщение в файл лога (серверная часть)
//
// Параметры:
//   Сообщение - Строка - Текст сообщения
//   Уровень - Строка - Уровень сообщения
//
&НаСервере
Процедура ЛогНаСервере(Сообщение, Уровень)
	Попытка
		// Получаем путь к файлу лога
		ПутьКОбработке = РеквизитФормыВЗначение("Объект").ПолучитьПутьКФайлуОбработки();
		ФайлОбработки = Новый Файл(ПутьКОбработке);
		КаталогОбработки = ФайлОбработки.Путь;
		
		ПутьКЛогу = КаталогОбработки + "debug.log";
		
		// Формируем строку лога
		ВремяМетка = Формат(ТекущаяДатаСеанса(), "ДФ='yyyy-MM-dd HH:mm:ss'");
		СтрокаЛога = СтрШаблон("[%1] [%2] %3", ВремяМетка, Уровень, Сообщение) + Символы.ПС;
		
		// Добавляем в файл
		ЗаписьТекста = Новый ЗаписьТекста(ПутьКЛогу, КодировкаТекста.UTF8, , Истина);
		ЗаписьТекста.Записать(СтрокаЛога);
		ЗаписьТекста.Закрыть();
		
	Исключение
		// Игнорируем ошибки записи лога - отказ логирования не должен прерывать основную работу
		// Не логируем ошибку логирования, чтобы не создать рекурсию
		ТекстОшибки = ""; // Заглушка для линтера
	КонецПопытки;
КонецПроцедуры

// Очищает файл лога
//
&НаСервере
Процедура ОчиститьЛог()
	Попытка
		ПутьКОбработке = РеквизитФормыВЗначение("Объект").ПолучитьПутьКФайлуОбработки();
		ФайлОбработки = Новый Файл(ПутьКОбработке);
		КаталогОбработки = ФайлОбработки.Путь;
		
		ПутьКЛогу = КаталогОбработки + "debug.log";
		
		ФайлЛога = Новый Файл(ПутьКЛогу);
		Если ФайлЛога.Существует() Тогда
			УдалитьФайлы(ПутьКЛогу);
		КонецЕсли;
	Исключение
		// Игнорируем ошибки очистки лога - некритичная операция
		// Не логируем ошибку, так как лог может быть недоступен
		ТекстОшибки = ""; // Заглушка для линтера
	КонецПопытки;
КонецПроцедуры

#КонецОбласти

#КонецОбласти
